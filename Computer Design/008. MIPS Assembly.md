MIPS 아키텍처는 레지스터 기반 구조를 사용하는 프로세서입니다. 이는 CPU가 연산을 수행할 때 주로 레지스터를 사용한다는 것을 의미합니다. 레지스터는 RAM과 같은 메모리의 한 형태이지만, RAM보다 훨씬 작고 훨씬 빠릅니다. MIPS에서는 CPU가 오직 레지스터와 특별한 즉시 값(immediate value)을 사용하여 연산을 수행할 수 있습니다. 이는 연산의 효율성과 단순성을 유지하기 위한 설계 철학에 기인합니다.

MIPS 프로세서에는 총 32개의 범용 레지스터가 존재합니다. 하지만 이들 중 일부는 특정 용도로 예약되어 있어 일반적인 연산에 사용할 수 없습니다. 예를 들어, 프로그램 카운터(program counter)라는 레지스터는 다음에 실행될 명령어의 메모리 주소를 저장합니다. 프로세서가 명령어를 실행하면, 프로그램 카운터는 자동으로 증가하여 다음 명령어의 주소를 가져오고 이를 실행하는 과정을 반복합니다. 이처럼 프로그램 카운터는 명령어 실행의 순서를 제어하는 중요한 역할을 합니다. 그러나 이 외에도 사용자가 직접 활용할 수 있는 여러 레지스터가 제공되어 프로그래밍 과정에서 중요한 도구로 사용됩니다.

MIPS 아키텍처는 RISC(Reduced Instruction Set Computer) 구조에 기반을 둡니다. RISC 구조는 복잡하고 논리적으로 집약적인 작업에 대해 개별 명령어를 할당하지 않는다는 특징이 있습니다. 이는 CISC(Complex Instruction Set Computer) 아키텍처와 대조적입니다. 예를 들어, DEC VAX와 같은 CISC 아키텍처는 다항식 곱셈이나 TCP/IP에서 자주 사용되는 순환 중복 검사(CRC)와 같은 작업을 수행하기 위해 별도의 명령어를 제공했습니다. 당시에는 이러한 복잡한 명령어들을 하드웨어에 구현하면 해당 작업을 사용하는 프로그램의 성능이 향상될 것이라고 여겨졌습니다. 하지만 이러한 설계는 프로세서의 구조를 매우 복잡하게 만들었습니다.

MIPS와 같은 RISC 아키텍처는 이러한 철학과 반대되는 접근 방식을 취합니다. RISC는 소수의 핵심 명령어만을 구현함으로써 설계를 단순화하고, 일반적인 명령어의 실행 속도를 극대화하며, 복잡한 작업을 여러 명령어로 나누어 구현하는 것이 더 효율적이라고 판단했습니다. 즉, 몇 백 개의 복잡한 명령어를 구현하는 대신, 몇 십 개의 기본 명령어만을 제공하여 하드웨어 설계를 단순화하고 실행 속도를 높였습니다. 이는 프로그램이 복잡한 작업을 수행하기 위해 더 많은 명령어를 사용해야 한다는 단점이 있지만, 대부분의 경우 이러한 추가적인 비용은 간소화된 설계와 높은 실행 속도에 의해 상쇄됩니다.

MIPS 아키텍처의 설계 결정은 여러 가지 결과를 낳았습니다. 첫 번째로, 모든 MIPS 명령어는 32비트 길이를 가지고 있습니다. 이는 명령어를 접근하고 디코딩하는 하드웨어를 단순화하는 데 기여합니다. 명령어의 길이가 고정되어 있기 때문에 프로세서가 명령어를 읽고 해석하는 과정이 예측 가능하고 효율적입니다. 또한, 고정된 길이로 인해 구현할 수 있는 명령어의 수가 제한됩니다. 이는 MIPS가 단순하고 핵심적인 명령어 집합만을 제공하는 RISC의 철학과 일치합니다.

두 번째로, 모든 MIPS 명령어는 세 가지 명령어 형식 중 하나에 속합니다. 이는 명령어를 디코딩하는 과정을 인간과 하드웨어 모두에게 단순하게 만듭니다. 명령어 형식이 규칙적이기 때문에 MIPS 명령어 집합을 배우는 데 필요한 시간이 줄어들고, 프로세서가 명령어를 처리하는 속도도 빨라집니다. MIPS의 이러한 설계는 단순성과 효율성을 목표로 한 RISC 아키텍처 철학의 핵심적인 예입니다.


### Registers

MIPS 아키텍처는 32개의 범용 레지스터와 32개의 부동소수점 레지스터를 제공합니다. 모든 레지스터는 달러 기호($)로 시작하며, 부동소수점 레지스터는 $f0, $f1, ..., $f31과 같이 명명됩니다. 범용 레지스터는 이름과 숫자 모두로 식별할 수 있으며, 이들은 각각 고유한 역할을 가집니다. MIPS 어셈블리 언어로 프로그래밍할 때는 보통 이름을 사용하는 것이 더 직관적이고 편리합니다.

범용 레지스터는 총 32개로, 이 중 $0 레지스터는 항상 값이 0으로 고정되어 있습니다. 이 레지스터는 읽기 전용이며, 값이 변경되지 않도록 설계되어 있습니다. 이는 프로그램에서 상수 0을 반복적으로 사용할 때 유용합니다. $1 레지스터는 어셈블러에서 예약되어 있으며, 사용자가 직접 사용하는 경우는 드뭅니다. $2와 $3 레지스터는 각각 함수의 첫 번째와 두 번째 반환 값을 저장하는 데 사용됩니다. $4에서 $7까지의 레지스터는 함수 호출 시 전달되는 첫 번째에서 네 번째 인수를 저장하는 데 사용됩니다. $8에서 $15까지는 임시 레지스터로, 계산 및 기타 작업에 자유롭게 사용할 수 있습니다. 이들은 함수 호출 시 값을 보존하지 않아도 되는 "call-clobbered" 레지스터로 분류됩니다. $16에서 $23까지는 저장 레지스터로, 함수 호출 간 값을 유지해야 할 때 사용됩니다. 이 레지스터를 사용할 경우 함수 진입 시 값을 저장하고, 함수 종료 시 복원해야 합니다.

이어지는 $24와 $25는 추가 임시 레지스터로, $8에서 $15와 동일한 방식으로 사용할 수 있습니다. $26과 $27은 운영 체제 커널에서 예약된 레지스터로, 일반적인 사용자 프로그램에서는 접근하지 않습니다. $28은 전역 포인터를 저장하는 데 사용되며, $29는 스택 포인터로, 함수 호출 스택의 현재 위치를 나타냅니다. $30은 프레임 포인터로, 함수 호출 스택에서 특정 프레임의 시작 위치를 나타냅니다. $31은 반환 주소를 저장하는 데 사용되며, 함수 호출이 완료된 후 제어를 반환할 위치를 지정합니다.

범용 레지스터 외에도 프로그래머가 직접 접근할 수 없는 몇 가지 특별한 레지스터가 존재합니다. 프로그램 카운터(PC)는 현재 실행 중인 명령어의 주소를 저장하며, 점프(jump)나 분기(branch) 명령어를 통해 제어 흐름을 변경할 때 사용됩니다. 또한, 곱셈이나 나눗셈과 같이 32비트를 초과하는 결과를 생성하는 연산에서는 "hi"와 "lo"라는 두 개의 특별한 레지스터가 사용됩니다. 곱셈 결과는 "hi"와 "lo"에 64비트로 저장되며, 나눗셈 결과는 몫이 "lo"에, 나머지가 "hi"에 저장됩니다. 이 레지스터에 접근하려면 별도의 명령어를 사용해야 합니다.

### Instruction Formats

MIPS 아키텍처에서 명령어는 R 형식, I 형식, J 형식의 세 가지 형식으로 나뉩니다. 각 형식은 서로 다른 연산 목적과 구조를 가지고 있으며, 특정 연산을 수행하기 위해 설계되었습니다. 이 명령어 형식들은 MIPS 아키텍처의 단순성과 효율성을 유지하기 위한 핵심적인 구성 요소입니다.

R 형식 명령어는 두 개의 소스 레지스터(rs와 rt)와 하나의 대상 레지스터(rd)를 사용하며, 주로 산술 연산이나 논리 연산과 같은 작업에 활용됩니다. 명령어의 일반적인 형태는 `instruction rd, rs, rt`로 표현되며, 여기서 rd는 연산 결과를 저장할 레지스터를, rs와 rt는 연산에 필요한 입력 값을 제공하는 소스 레지스터를 나타냅니다. 예를 들어, `add $t0, $t1, $t2`라는 명령어는 `$t1`과 `$t2` 레지스터의 값을 더한 결과를 `$t0` 레지스터에 저장합니다.

R 형식 명령어는 32비트로 구성되며, opcode, rs, rt, rd, shamt, func의 여섯 가지 필드로 나뉩니다. 이 중 opcode는 연산 코드를 나타내지만, R 형식 명령어에서는 항상 0으로 고정됩니다. 대신 연산의 세부적인 종류는 func 필드를 통해 결정됩니다. rs와 rt는 각각 첫 번째와 두 번째 소스 레지스터를 나타내며, rd는 연산 결과를 저장할 대상 레지스터를 지정합니다. shamt 필드는 시프트 연산에서 사용되는 시프트 양을 나타내지만, 일반적인 산술 연산에서는 0으로 설정됩니다. 마지막으로 func 필드는 특정 R 형식 명령어를 구분하는 역할을 합니다. 예를 들어, `add` 명령어의 func 값은 `100000`으로 설정됩니다.

R 형식 명령어의 예로 시프트 연산을 들 수 있습니다. `sll $t5, $t4, 2`라는 명령어는 $t4 레지스터의 값을 왼쪽으로 두 비트 시프트하고 결과를 $t5 레지스터에 저장합니다. 이 명령어의 opcode는 R 형식이므로 0으로 설정되며, rs 필드는 사용되지 않으므로 0으로 설정됩니다. rt는 $t4를 나타내며, rd는 $t5를 나타냅니다. shamt는 시프트 양인 2로 설정되며, func 값은 `sll` 명령어에 해당하는 000000입니다. 이 명령어는 다음과 같이 기계어로 표현됩니다: `000000 00000 01100 01101 00010 000000`.

I 형식 명령어는 두 개의 레지스터(rs와 rt)와 16비트 즉시 값(immediate)을 사용합니다. 즉시 값은 명령어 자체에 포함된 값으로, 메모리에서 값을 로드하지 않고도 바로 사용할 수 있습니다. 이 형식은 상수를 다루거나 메모리 접근, 조건 분기와 같은 작업에 적합합니다. I 형식 명령어의 일반적인 형태는 `instruction rt, rs, imm`입니다. 여기서 rt는 결과가 저장될 레지스터를, rs는 입력 레지스터를, imm은 즉시 값을 나타냅니다. 예를 들어, `addi $t0, $t1, 5`라는 명령어는 $t1 레지스터의 값에 5를 더한 결과를 $t0 레지스터에 저장합니다. I 형식 명령어는 opcode, rs, rt, imm 필드로 나뉘며, opcode는 수행할 연산을 지정합니다. rs와 rt는 각각 소스 레지스터와 대상 레지스터를 나타내고, imm은 즉시 값을 저장합니다. imm 필드는 부호 확장(sign-extend) 또는 0 확장(zero-extend)을 통해 32비트로 변환될 수 있습니다.

I 형식 명령어의 또 다른 예로 `beq $t0, $zero, label`을 들 수 있습니다. 이 명령어는 $t0 레지스터의 값이 0과 같을 경우 프로그램 실행을 label로 이동시킵니다. 이 명령어의 opcode는 분기 명령어에 해당하는 값으로 설정되며, rs는 $t0, rt는 $zero로 설정됩니다. imm 필드는 분기 대상 주소와 현재 명령어 주소 간의 차이를 나타냅니다. 이때 imm 값은 16비트로 표현되며, 프로그램 카운터(PC)의 현재 값과 비교하여 상대적으로 계산됩니다.

J 형식 명령어는 프로그램 흐름을 특정 절대 주소로 이동시키는 데 사용됩니다. J 형식 명령어는 opcode와 addr 필드로 구성되며, addr 필드는 명령어 주소를 나타냅니다. J 형식 명령어는 프로그램의 특정 위치로 점프하거나 함수 호출과 같은 작업에 적합합니다. 예를 들어, `j label1`이라는 명령어는 label1이 위치한 주소로 프로그램 실행을 이동시킵니다. J 형식 명령어는 32비트 주소를 처리하기 위해 addr 필드의 마지막 두 비트를 생략하고 하드웨어가 이를 다시 추가하도록 설계되었습니다. 이는 모든 명령어가 4바이트 단위로 정렬되어 있기 때문입니다. addr 필드는 26비트로 표현되며, 실제 주소는 4배 확장되어 사용됩니다. 예를 들어, label1의 주소가 120이라면, addr 필드는 120의 이진 표현에서 마지막 두 비트를 제거한 값으로 설정됩니다.

J 형식 명령어의 예로는 `j label1` 외에도 함수 호출 시 사용되는 `jal` 명령어가 있습니다. `jal` 명령어는 현재 프로그램 카운터 값을 $ra 레지스터에 저장한 후 지정된 주소로 점프합니다. 이는 함수 호출 후 반환 주소를 저장하는 데 사용됩니다. J 형식 명령어는 프로그램의 제어 흐름을 변경하는 데 필수적인 역할을 합니다.


### MIPS Instructions

MIPS 어셈블리 언어는 컴퓨터 구조와 밀접하게 연관된 저수준 프로그래밍 언어로, 주로 학습 목적으로 사용됩니다. 이 언어를 이해하기 위해서는 몇 가지 주요 요소를 알아야 합니다. 여기에는 레이블(labels), 섹션(sections), 지시어(directives), 주석(comments), 그리고 명령(commands)이 포함됩니다.

#### Comments

MIPS 어셈블리에서 주석은 코드의 가독성을 높이고, 코드가 수행하는 작업을 설명하는 데 사용됩니다. 주석은 `#` 기호로 시작하며, 이 기호 이후의 모든 내용은 어셈블러에 의해 무시됩니다. 주석은 코드의 실행에 영향을 미치지 않으며, 개발자나 코드 리뷰어가 코드의 의도를 이해하는 데 도움을 줍니다. 예를 들어, `# 이 코드는 두 수를 더합니다`와 같이 작성할 수 있습니다.

#### Labels

MIPS 어셈블리 언어에서 레이블(label)은 프로그램의 특정 위치를 참조하거나 식별하기 위해 사용됩니다. 레이블은 코드 작성 및 유지보수를 용이하게 하며, 특히 반복문, 조건문, 그리고 점프 명령어와 같은 제어 흐름 구조에서 필수적인 역할을 합니다. 레이블을 사용하면 코드의 특정 부분을 이름으로 식별할 수 있으므로, 코드의 줄 번호를 직접 계산하거나 특정 메모리 주소를 기억할 필요가 없습니다.

레이블은 어셈블리 코드에서 명령어나 데이터 앞에 작성되며, 다음과 같은 형식으로 정의됩니다:

```
name:
```

여기서 `name`은 사용자가 레이블에 부여하는 이름입니다. 이 이름은 고유해야 하며, MIPS 명령어와 동일한 이름을 사용할 수 없습니다. 예를 들어, `add`나 `sub`와 같은 MIPS 명령어 이름으로 레이블을 정의하면 어셈블러는 이를 명령어로 혼동하여 오류를 발생시킵니다.

레이블은 프로그램의 실행 흐름을 제어하는 데 자주 사용됩니다. MIPS 어셈블리에서 점프(jump) 명령어(`j`, `jal`, `jr` 등)와 분기(branch) 명령어(`beq`, `bne`, `blez` 등)는 레이블을 참조하여 프로그램의 실행 위치를 변경합니다. 예를 들어, 반복문을 구현할 때 레이블을 사용하면 반복문의 시작 지점으로 점프할 수 있습니다. 또한, 조건문에서 특정 조건이 충족되었을 때 실행해야 할 코드 블록의 시작 위치를 레이블로 지정할 수 있습니다.

레이블은 어셈블리 코드 작성자뿐만 아니라 어셈블러에게도 유용합니다. 어셈블러는 레이블을 사용하여 코드와 데이터를 메모리에 적절히 배치하고, 점프 및 분기 명령어에서 참조하는 주소를 계산합니다. 레이블은 실제 기계 코드로 변환될 때 최종 프로그램에 포함되지 않으며, 오직 어셈블리 코드 작성 및 변환 과정에서만 사용됩니다. 따라서 레이블은 코드의 가독성을 높이고, 어셈블리 코드와 기계 코드 간의 변환을 간소화하는 역할을 합니다.

C 언어와 같은 고급 프로그래밍 언어에서도 레이블은 존재합니다. C 언어에서 레이블은 `goto` 문과 함께 사용되며, 특정 코드 블록으로 이동하는 데 사용됩니다. MIPS 어셈블리 언어에서의 레이블은 이러한 C 언어의 레이블과 유사한 역할을 합니다. 다만, 어셈블리 언어는 고급 언어보다 더 낮은 수준에서 실행 흐름을 제어하기 때문에, 레이블을 사용하는 빈도가 더 높고 중요한 위치에서 활용됩니다.

레이블은 데이터 섹션에서도 사용됩니다. 데이터 섹션에서 레이블은 특정 데이터의 위치를 참조하는 데 사용됩니다. 예를 들어, 문자열이나 배열과 같은 데이터를 정의할 때 레이블을 사용하면 해당 데이터의 시작 위치를 메모리에서 참조할 수 있습니다. 이를 통해 텍스트 섹션에서 데이터를 쉽게 읽거나 쓸 수 있습니다. 

#### Sections

MIPS 어셈블리 언어에서 섹션은 프로그램을 논리적으로 나누는 방법입니다. 어셈블리 프로그램은 데이터와 명령어로 구성되며, 이 두 요소를 분리하여 관리하는 것이 필요합니다. 프로그램이 메모리에 로드될 때, 프로세서는 실행을 시작할 위치(엔트리 포인트)만 알고 있으면 됩니다. 이후에는 명령어 포인터(instruction pointer)를 증가시키면서 순차적으로 명령어를 실행합니다. 하지만 만약 데이터가 명령어 코드 사이에 섞여 있다면, 프로세서는 메모리에서 읽은 정보가 명령어인지 데이터인지 구분해야 합니다. 이러한 구분 작업은 프로세서를 더 복잡하게 만들고, 성능에도 영향을 미칠 수 있습니다.

이러한 문제를 해결하기 위해 MIPS 어셈블리 언어에서는 명령어와 데이터를 별도의 섹션으로 분리합니다. 각각의 섹션은 특정한 역할을 가지며, 프로세서가 이를 효율적으로 처리할 수 있도록 돕습니다. 섹션을 사용하면 명령어와 데이터가 메모리에서 물리적으로 분리되며, 프로세서는 명령어와 데이터를 혼동하지 않고 처리할 수 있습니다. 즉, 명령어는 텍스트 섹션(text section)에, 데이터는 데이터 섹션(data section)에 배치됩니다.

텍스트 섹션은 어셈블리 프로그램의 명령어를 담고 있습니다. 텍스트 섹션은 `.text` 지시어로 시작하며, 이 섹션 안에 작성된 내용은 프로세서가 실행할 명령어로 해석됩니다. 어셈블리 언어에서 작성한 명령어는 기계어로 번역되어 텍스트 섹션에 저장됩니다. 텍스트 섹션은 프로그램의 실행 흐름을 정의하며, 프로세서가 직접 읽고 실행하는 명령어 집합을 포함합니다.

데이터 섹션은 프로그램에서 사용하는 데이터를 저장합니다. 데이터 섹션은 `.data` 지시어로 시작하며, 이 섹션 안에 선언된 변수와 데이터는 프로그램 실행 중에 참조됩니다. 데이터 섹션에 저장된 데이터는 정적(static) 데이터로 간주되며, 프로그램 실행 중에 변경되지 않거나 변경이 제한됩니다. 예를 들어, 상수 값, 문자열, 배열, 그리고 정적 변수 등이 데이터 섹션에 저장됩니다. 데이터 섹션은 프로세서가 실행 중에 데이터를 읽거나 쓰는 작업을 수행할 수 있도록 메모리 공간을 제공합니다.

#### Directives

MIPS 어셈블리 언어에서 지시어(directive)는 어셈블러가 특정 작업을 수행하도록 지시하는 명령입니다. 지시어는 프로세서가 직접 실행하는 명령어와는 다르며, 주로 코드를 작성하거나 데이터를 관리하는 과정에서 개발자의 편의를 위해 사용됩니다. 예를 들어, 변수를 정의하거나 메모리 공간을 할당하는 작업에서 지시어가 사용됩니다. 여기서는 변수를 정의하고 메모리를 정렬하는 과정을 중심으로 설명하겠습니다.

먼저, 변수를 정의하기 위해서는 데이터 섹션으로 전환해야 합니다. 데이터 섹션은 `.data`로 시작하며, 프로그램에서 사용할 데이터를 선언하는 공간입니다. 데이터 섹션으로 전환한 후에는 변수를 참조할 수 있도록 레이블(label)을 생성합니다. 레이블은 변수를 식별할 수 있는 이름을 제공하며, 이를 통해 메모리의 특정 위치를 쉽게 참조할 수 있습니다. 레이블은 `variable_name:`과 같은 형식으로 작성됩니다. 여기서 `variable_name`은 사용자가 지정하는 변수의 이름입니다.

변수 이름을 지정한 후에는 해당 변수에 필요한 메모리 공간을 할당해야 합니다. MIPS 어셈블리에서는 `.space` 지시어를 사용하여 메모리 공간을 예약할 수 있습니다. 예를 들어, 정수 하나를 저장하려면 4바이트의 메모리가 필요하므로 `.space 4`를 작성합니다. 이렇게 하면 어셈블러는 해당 변수에 대해 4바이트의 메모리를 할당합니다. 이때, 메모리 공간은 실제 값이 저장될 위치를 확보하는 역할을 하며, 값 자체는 프로그램 실행 중에 저장됩니다.

메모리를 할당한 후에는 정렬(alignment)을 수행해야 합니다. 정렬은 데이터가 메모리의 올바른 경계(boundary)에서 시작되도록 보장하는 과정입니다. MIPS 프로세서와 같은 구조에서는 데이터가 올바르게 정렬되지 않으면 접근 시 오류가 발생하거나 성능이 저하될 수 있습니다. 정렬을 수행하기 위해서는 `.align` 지시어를 사용합니다. `.align` 지시어는 데이터가 2의 거듭제곱 바이트 경계에서 시작되도록 합니다. 예를 들어, `.align 2`는 데이터가 4바이트(2^2) 경계에서 시작되도록 정렬합니다. 이는 32비트(4바이트) 정수와 같은 데이터를 저장할 때 적합합니다.

정렬은 메모리 공간을 할당하기 전에 수행해야 합니다. 이는 정렬 지시어가 이후에 선언되는 데이터의 시작 위치를 조정하기 때문입니다. 따라서, 데이터 섹션에서 변수를 정의할 때는 `.align` 지시어를 먼저 작성한 후, `.space` 지시어로 메모리 공간을 예약하는 순서를 따릅니다. 예를 들어, 6개의 32비트 정수(즉, 6개의 워드)를 저장하기 위해서는 24바이트의 메모리가 필요합니다. 이를 정렬하려면 다음과 같이 작성합니다:

```
.data
.align 2
my_var_name:
.space 24
```

위 코드는 데이터 섹션으로 전환한 후, `.align 2`를 사용하여 데이터가 4바이트 경계에서 시작되도록 정렬합니다. 이후, `my_var_name`이라는 이름의 레이블을 정의하고, `.space 24`를 통해 24바이트의 메모리를 예약합니다. 이렇게 하면 `my_var_name`이라는 이름으로 6개의 32비트 정수를 저장할 수 있는 공간이 확보됩니다.

변수를 정의하고 메모리를 할당한 후에는 다시 텍스트 섹션으로 전환하여 프로그램의 명령어를 작성할 수 있습니다. 텍스트 섹션은 `.text`로 시작하며, 프로그램의 실행 논리를 구현하는 명령어를 포함합니다. 데이터 섹션에서 정의한 변수는 텍스트 섹션에서 참조하여 사용할 수 있습니다.


### Arithmetic / Logic Instructions

#### Register Arithmetic Instructions

**1. add (R Type)**  
`add` 명령어는 두 소스 레지스터의 값을 더한 후, 결과를 목적 레지스터에 저장합니다. 이 명령어는 signed(부호 있는)와 unsigned(부호 없는) 숫자를 구분하지 않고 동일하게 처리합니다. 내부적으로 2의 보수법을 사용하여 음수도 자동으로 처리됩니다.  
- 예시:  
  ```
  add $t0, $t1, $t2  # $t0 = $t1 + $t2
  ```
  만약 $t1에 5, $t2에 3이 저장되어 있다면, $t0에는 8이 저장됩니다.

**2. sub (R Type)**  
`sub` 명령어는 첫 번째 소스 레지스터 값에서 두 번째 소스 레지스터 값을 뺀 후, 결과를 목적 레지스터에 저장합니다.  
- 예시:  
  ```
  sub $t0, $t1, $t2  # $t0 = $t1 - $t2
  ```
  만약 $t1에 10, $t2에 4가 저장되어 있다면, $t0에는 6이 저장됩니다.

**3. addu (R Type)**  
`addu` 명령어는 `add`와 유사하지만, overflow(오버플로우)가 발생해도 이를 무시합니다. 오버플로우가 발생하지 않는 unsigned 연산에 적합합니다.  
- 예시:  
  ```
  addu $t0, $t1, $t2  # $t0 = $t1 + $t2 (오버플로우 무시)
  ```

**4. subu (R Type)**  
`subu` 명령어는 `sub`와 유사하지만, 마찬가지로 오버플로우를 무시합니다.  
- 예시:  
  ```
  subu $t0, $t1, $t2  # $t0 = $t1 - $t2 (오버플로우 무시)
  ```

#### Multiplication and Division

곱셈과 나눗셈 연산은 다른 R-Type 명령어와 달리, 두 개의 피연산자를 사용하며 결과를 64비트의 특별한 HI와 LO 레지스터에 저장합니다. HI는 상위 32비트, LO는 하위 32비트를 나타냅니다.

**1. mult (R Type)**  
`mult` 명령어는 두 피연산자를 곱하고, 결과를 HI와 LO 레지스터에 저장합니다. 이 명령어는 signed 값을 처리하며, 곱셈 결과가 64비트로 확장됩니다.  
- 예시:  
  ```
  mult $t1, $t2  # HI:LO = $t1 * $t2
  ```
  만약 $t1에 3, $t2에 4가 저장되어 있다면, LO에 12가 저장됩니다.  

**2. multu (R Type)**  
`multu` 명령어는 unsigned 값을 곱하여 HI와 LO 레지스터에 저장합니다.  
- 예시:  
  ```
  multu $t1, $t2  # HI:LO = $t1 * $t2 (unsigned)
  ```

**3. div (R Type)**  
`div` 명령어는 첫 번째 피연산자를 두 번째 피연산자로 나눕니다. 몫은 LO 레지스터에, 나머지는 HI 레지스터에 저장됩니다.  
- 예시:  
  ```
  div $t1, $t2  # LO = $t1 / $t2, HI = $t1 % $t2
  ```
  만약 $t1에 10, $t2에 3이 저장되어 있다면, LO에는 3이, HI에는 1이 저장됩니다.

**4. divu (R Type)**  
`divu` 명령어는 unsigned 값을 나누며, 결과를 LO와 HI에 저장합니다.  
- 예시:  
  ```
  divu $t1, $t2  # LO = $t1 / $t2, HI = $t1 % $t2 (unsigned)
  ```

#### 64-Bit Results and Accessing HI/LO

**1. mfhi (R Type)**  
`mfhi` 명령어는 HI 레지스터의 값을 특정 레지스터로 이동합니다.  
- 예시:  
  ```
  mfhi $t0  # $t0 = HI
  ```

**2. mflo (R Type)**  
`mflo` 명령어는 LO 레지스터의 값을 특정 레지스터로 이동합니다.  
- 예시:  
  ```
  mflo $t0  # $t0 = LO
  ```

#### Register Logic Instructions

**1. and (R Type)**  
`and` 명령어는 두 피연산자에 대해 비트 단위 AND 연산을 수행하고, 결과를 목적 레지스터에 저장합니다.  
- 예시:  
  ```
  and $t0, $t1, $t2  # $t0 = $t1 & $t2
  ```
  만약 $t1에 0b1100, $t2에 0b1010이 저장되어 있다면, $t0에는 0b1000이 저장됩니다.

**2. or (R Type)**  
`or` 명령어는 두 피연산자에 대해 비트 단위 OR 연산을 수행합니다.  
- 예시:  
  ```
  or $t0, $t1, $t2  # $t0 = $t1 | $t2
  ```

**3. nor (R Type)**  
`nor` 명령어는 두 피연산자에 대해 비트 단위 NOR 연산을 수행합니다.  
- 예시:  
  ```
  nor $t0, $t1, $t2  # $t0 = ~($t1 | $t2)
  ```

**4. xor (R Type)**  
`xor` 명령어는 두 피연산자에 대해 비트 단위 XOR 연산을 수행합니다.  
- 예시:  
  ```
  xor $t0, $t1, $t2  # $t0 = $t1 ^ $t2
  ```

#### Immediate Arithmetic Instructions

**1. addi (I Type)**  
`addi` 명령어는 소스 레지스터의 값에 16비트 즉시 값을 더하고, 결과를 목적 레지스터에 저장합니다.  
- 예시:  
  ```
  addi $t0, $t1, 5  # $t0 = $t1 + 5
  ```

**2. addiu (I Type)**  
`addiu` 명령어는 `addi`와 유사하지만, 오버플로우를 무시합니다.  
- 예시:  
  ```
  addiu $t0, $t1, 5  # $t0 = $t1 + 5 (오버플로우 무시)
  ```

#### Immediate Logic Instructions

즉시 값(immediate value)을 사용하여 논리 연산을 수행하는 명령어들은 16비트 즉시 값을 32비트로 확장한 뒤 연산을 수행합니다. 이 과정에서 즉시 값은 zero-extend(0으로 확장)됩니다.

**1. andi (I Type)**  
`andi` 명령어는 소스 레지스터의 값과 16비트 즉시 값에 대해 비트 단위 AND 연산을 수행하고, 결과를 목적 레지스터에 저장합니다.  
- 예시:  
  ```
  andi $t0, $t1, 0x0F  # $t0 = $t1 & 0x0000000F
  ```
  만약 $t1에 0x1234가 저장되어 있다면, $t0에는 0x0004가 저장됩니다. 즉시 값 0x0F는 32비트로 확장되어 연산됩니다.

**2. ori (I Type)**  
`ori` 명령어는 소스 레지스터의 값과 16비트 즉시 값에 대해 비트 단위 OR 연산을 수행하고, 결과를 목적 레지스터에 저장합니다.  
- 예시:  
  ```
  ori $t0, $t1, 0x0F  # $t0 = $t1 | 0x0000000F
  ```
  만약 $t1에 0x1234가 저장되어 있다면, $t0에는 0x123F가 저장됩니다.

**3. xori (I Type)**  
`xori` 명령어는 소스 레지스터의 값과 16비트 즉시 값에 대해 비트 단위 XOR 연산을 수행하고, 결과를 목적 레지스터에 저장합니다.  
- 예시:  
  ```
  xori $t0, $t1, 0x0F  # $t0 = $t1 ^ 0x0000000F
  ```
  만약 $t1에 0x1234가 저장되어 있다면, $t0에는 0x123B가 저장됩니다.

#### Shift Instructions

Shift 명령어는 레지스터 값의 비트를 왼쪽 또는 오른쪽으로 이동시키는 연산을 수행합니다. 이동된 비트는 버려지고, 빈 자리는 0 또는 1로 채워집니다. Shift 연산은 데이터를 정렬하거나 특정 비트를 추출하는 데 유용합니다.

**1. sll (R Type)**  
`sll` 명령어는 논리적 왼쪽 시프트(Logical Shift Left)를 수행합니다. 지정된 시프트 양(shamt)만큼 비트를 왼쪽으로 이동시키며, 오른쪽 빈 자리는 0으로 채웁니다.  
- 예시:  
  ```
  sll $t0, $t1, 2  # $t0 = $t1 << 2
  ```
  만약 $t1에 0b00001111이 저장되어 있다면, $t0에는 0b00111100이 저장됩니다.

**2. srl (R Type)**  
`srl` 명령어는 논리적 오른쪽 시프트(Logical Shift Right)를 수행합니다. 지정된 시프트 양만큼 비트를 오른쪽으로 이동시키며, 왼쪽 빈 자리는 0으로 채웁니다.  
- 예시:  
  ```
  srl $t0, $t1, 2  # $t0 = $t1 >> 2
  ```
  만약 $t1에 0b00001111이 저장되어 있다면, $t0에는 0b00000011이 저장됩니다.

**3. sra (R Type)**  
`sra` 명령어는 산술적 오른쪽 시프트(Arithmetic Shift Right)를 수행합니다. 지정된 시프트 양만큼 비트를 오른쪽으로 이동시키며, 왼쪽 빈 자리는 부호 비트(가장 왼쪽 비트)로 채웁니다. 만약 값이 음수라면 1로 채워지고, 양수라면 0으로 채워집니다.  
- 예시:  
  ```
  sra $t0, $t1, 2  # $t0 = $t1 >> 2 (부호 비트 채움)
  ```
  만약 $t1에 0b11110000(음수 값)이 저장되어 있다면, $t0에는 0b11111100이 저장됩니다.

**4. sllv (R Type)**  
`sllv` 명령어는 `sll`과 동일하지만, 시프트 양(shamt)이 레지스터(rs)에 저장된 값에 의해 결정됩니다.  
- 예시:  
  ```
  sllv $t0, $t1, $t2  # $t0 = $t1 << $t2
  ```
  만약 $t1에 0b00001111, $t2에 2가 저장되어 있다면, $t0에는 0b00111100이 저장됩니다.

**5. srlv (R Type)**  
`srlv` 명령어는 `srl`과 동일하지만, 시프트 양이 레지스터(rs)에 저장된 값에 의해 결정됩니다.  
- 예시:  
  ```
  srlv $t0, $t1, $t2  # $t0 = $t1 >> $t2
  ```

**6. srav (R Type)**  
`srav` 명령어는 `sra`와 동일하지만, 시프트 양이 레지스터(rs)에 저장된 값에 의해 결정됩니다.  
- 예시:  
  ```
  srav $t0, $t1, $t2  # $t0 = $t1 >> $t2 (부호 비트 채움)
  ```


### Control Flow Instructions


MIPS의 제어 흐름 명령어(Control Flow Instructions)는 프로그램 실행 순서를 변경하거나 조건에 따라 특정 명령어로 분기(branch)하는 데 사용됩니다.

#### Jump Instructions

점프 명령어는 PC(Program Counter) 레지스터에 새로운 값을 로드하여 실행 흐름을 변경합니다. PC는 현재 실행 중인 명령어의 주소를 저장하며, 점프 명령어는 이 값을 새로운 위치로 설정하여 다음 명령어를 해당 위치에서 가져오게 만듭니다.

**1. j (J Type)**  
`j` 명령어는 PC 레지스터에 즉시 값(immediate value)을 로드합니다. 이 값은 숫자로 된 오프셋이나 레이블일 수 있으며, 어셈블러는 레이블을 오프셋으로 변환합니다.  
- 예시:  
  ```
  j TargetLabel  # PC ← TargetLabel
  ```
  만약 `TargetLabel`이 메모리 주소 0x00400020을 가리킨다면, PC는 0x00400020으로 설정되고, 다음 명령어는 해당 주소에서 실행됩니다.

**2. jr (R Type)**  
`jr` 명령어는 PC 레지스터에 특정 레지스터에 저장된 값을 로드합니다. 이는 동적으로 점프할 위치를 결정할 수 있게 합니다.  
- 예시:  
  ```
  jr $t0  # PC ← $t0
  ```
  만약 $t0에 0x00400030이 저장되어 있다면, PC는 0x00400030으로 설정됩니다.

#### Jump and Link Instructions

Jump and Link 명령어는 점프 명령어와 유사하지만, 점프 직후 복귀할 수 있도록 현재 명령어의 다음 주소(PC + 4)를 반환 주소 레지스터($ra, $31)에 저장합니다. 이를 통해 서브루틴 호출 및 복귀를 구현할 수 있습니다.

**1. jal (J Type)**  
`jal` 명령어는 `j` 명령어와 동일하게 점프를 수행하지만, 반환 주소를 $ra 레지스터에 저장합니다.  
- 예시:  
  ```
  jal MySubroutine  # $ra ← PC + 4, PC ← MySubroutine
  ```
  만약 `MySubroutine`이 메모리 주소 0x00400040을 가리킨다면, $ra에는 현재 명령어의 다음 주소가 저장되고, PC는 0x00400040으로 설정됩니다.

**2. jalr (R Type)**  
`jalr` 명령어는 `jr` 명령어와 동일하게 동적 점프를 수행하지만, 반환 주소를 $ra 또는 지정된 레지스터에 저장합니다.  
- 예시:  
  ```
  jalr $t0  # $ra ← PC + 4, PC ← $t0
  ```
  만약 $t0에 0x00400050이 저장되어 있다면, $ra에는 현재 명령어의 다음 주소가 저장되고, PC는 0x00400050으로 설정됩니다.

**서브루틴 호출 예제:**  
서브루틴 호출과 복귀는 아래와 같이 구현됩니다.  
```
jal MySub  # 서브루틴 호출
...
MySub:
  # 서브루틴 내용
  jr $ra   # 반환
```

#### Branch Instructions

분기 명령어는 조건에 따라 프로그램 실행 흐름을 변경합니다. 조건이 참이면 PC 레지스터에 즉시 값(imm)을 더한 새로운 주소로 이동하며, 그렇지 않으면 다음 명령어를 실행합니다. 계산된 주소는 `PC + 4 + imm`입니다.

**1. beq (I Type)**  
`beq` 명령어는 두 레지스터 값이 같을 때 분기를 수행합니다.  
- 예시:  
  ```
  beq $t0, $t1, Target  # if ($t0 == $t1) PC ← PC + 4 + imm
  ```
  만약 $t0와 $t1의 값이 같다면, PC는 `Target`으로 분기합니다.

**2. bne (I Type)**  
`bne` 명령어는 두 레지스터 값이 다를 때 분기를 수행합니다.  
- 예시:  
  ```
  bne $t0, $t1, Target  # if ($t0 != $t1) PC ← PC + 4 + imm
  ```

**3. bgez (I Type)**  
`bgez` 명령어는 특정 레지스터 값이 0 이상일 때 분기를 수행합니다.  
- 예시:  
  ```
  bgez $t0, Target  # if ($t0 >= 0) PC ← PC + 4 + imm
  ```

**4. blez (I Type)**  
`blez` 명령어는 특정 레지스터 값이 0 이하일 때 분기합니다.  
- 예시:  
  ```
  blez $t0, Target  # if ($t0 <= 0) PC ← PC + 4 + imm
  ```

**5. bgtz (I Type)**  
`bgtz` 명령어는 특정 레지스터 값이 0보다 클 때 분기합니다.  
- 예시:  
  ```
  bgtz $t0, Target  # if ($t0 > 0) PC ← PC + 4 + imm
  ```

**6. bltz (I Type)**  
`bltz` 명령어는 특정 레지스터 값이 0보다 작을 때 분기합니다.  
- 예시:  
  ```
  bltz $t0, Target  # if ($t0 < 0) PC ← PC + 4 + imm
  ```


#### Set Instructions

Set 명령어는 조건에 따라 목적 레지스터(rd)에 1 또는 0을 설정합니다. 특정 조건을 만족하면 1, 그렇지 않으면 0을 저장하며, 이를 통해 조건 기반 연산을 구현할 수 있습니다.

**1. slt (R Type)**  
`slt` 명령어는 첫 번째 레지스터 값이 두 번째 레지스터 값보다 작으면 1을, 그렇지 않으면 0을 저장합니다.  
- 예시:  
  ```
  slt $t0, $t1, $t2  # if ($t1 < $t2) $t0 ← 1 else $t0 ← 0
  ```

**2. slti (I Type)**  
`slti` 명령어는 첫 번째 레지스터 값이 즉시 값보다 작으면 1을, 그렇지 않으면 0을 저장합니다.  
- 예시:  
  ```
  slti $t0, $t1, 10  # if ($t1 < 10) $t0 ← 1 else $t0 ← 0
  ```

**3. sltu (R Type)**  
`sltu` 명령어는 unsigned 비교를 수행합니다. 첫 번째 레지스터 값이 두 번째 레지스터 값보다 작으면 1을, 그렇지 않으면 0을 저장합니다.  
- 예시:  
  ```
  sltu $t0, $t1, $t2  # if ($t1 < $t2) $t0 ← 1 else $t0 ← 0 (unsigned)
  ```

**4. sltiu (I Type)**  
`sltiu` 명령어는 unsigned 비교를 수행하며, 첫 번째 레지스터 값이 즉시 값보다 작으면 1을, 그렇지 않으면 0을 저장합니다.  
- 예시:  
  ```
  sltiu $t0, $t1, 20  # if ($t1 < 20) $t0 ← 1 else $t0 ← 0 (unsigned)
  ```


### Memory Instructions

