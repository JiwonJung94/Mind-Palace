### 컴퓨터 하드웨어의 연산자 (Operations of the Computer Hardware)

모든 컴퓨터는 산술 연산을 수행할 수 있어야 합니다. MIPS 어셈블리 언어 표기법에서  
```
add a, b, c
```
는 컴퓨터에게 두 변수 $b$와 $c$를 더한 값을 변수 $a$에 저장하라는 명령을 내립니다. 이 표기법은 매우 엄격하여, 각 MIPS 산술 명령어는 한 번에 하나의 연산만 수행하며 반드시 정확히 세 개의 변수를 가져야 합니다. 예를 들어, 네 개의 변수 $b$, $c$, $d$, $e$의 합을 변수 $a$에 저장하려고 한다고 가정해봅시다. 

다음과 같은 명령어 순서를 통해 네 개의 변수를 더할 수 있습니다:  
```
add a, b, c  # b와 c의 합을 a에 저장  
add a, a, d  # b, c, d의 합을 a에 저장  
add a, a, e  # b, c, d, e의 합을 a에 저장  
```  
따라서, 네 개의 변수를 더하려면 총 세 개의 명령어가 필요합니다.  

덧셈과 같은 연산에서 자연스러운 피연산자의 수는 세 개입니다: 더해질 두 숫자와 합을 저장할 위치입니다. 모든 명령어가 정확히 세 개의 피연산자를 가지도록 요구하는 것은 하드웨어를 단순하게 유지하려는 철학에 부합합니다. 피연산자의 수가 가변적인 하드웨어는 고정된 수의 피연산자를 처리하는 하드웨어보다 더 복잡하기 때문입니다. 이 상황은 하드웨어 설계의 세 가지 기본 원칙 중 첫 번째를 보여줍니다:  

**설계 원칙 1: 단순함은 규칙성을 선호한다.**  

### 컴퓨터 하드웨어의 피연산자(Operands of the Computer Hardware)

고급 언어에서 작성된 프로그램과 달리, 산술 명령어의 피연산자는 제한을 받습니다. 이 피연산자는 하드웨어에 직접 내장된 특별한 위치인 **레지스터**(register)에서만 가져와야 합니다. 레지스터는 하드웨어 설계에서 사용되는 기본 요소로, 컴퓨터가 완성되면 프로그래머에게도 노출됩니다. 따라서 레지스터를 컴퓨터 구성의 벽돌로 생각할 수 있습니다.

프로그래밍 언어의 변수와 레지스터 간의 주요 차이점 중 하나는 레지스터의 개수가 제한적이라는 점입니다.
레지스터의 수가 제한된 이유는 하드웨어 기술의 세 가지 기본 설계 원칙 중 두 번째 원칙에서 찾을 수 있습니다:

**설계 원칙 2: 작을수록 빠르다(Smaller is faster).**

레지스터의 개수가 매우 많아지면, 전자 신호가 더 먼 거리를 이동해야 하므로 클록 주기(clock cycle) 시간이 증가할 수 있습니다. "작을수록 빠르다"와 같은 지침은 절대적인 규칙이 아닙니다. 하지만 이러한 관찰의 진실성은 컴퓨터 설계자들에게 중요한 고려 사항으로 작용합니다. 이 경우, 설계자는 프로그램이 더 많은 레지스터를 요구하는 욕구와 클록 주기를 빠르게 유지하려는 설계자의 목표 사이에서 균형을 맞춰야 합니다.

또 다른 이유는 명령어 형식에서 필요한 비트 수 때문입니다.

**메모리 피연산자**  
프로그래밍 언어에는 단일 데이터 요소를 포함하는 간단한 변수들이 있습니다. 그러나 프로그래밍 언어는 배열과 구조체와 같은 더 복잡한 데이터 구조도 제공합니다. 이러한 복잡한 데이터 구조는 컴퓨터의 레지스터보다 훨씬 더 많은 데이터 요소를 포함할 수 있습니다. 그렇다면 컴퓨터는 이러한 대규모 구조를 어떻게 표현하고 접근할 수 있을까요?

프로세서는 레지스터에 소량의 데이터만 저장할 수 있지만, 컴퓨터 메모리는 수십억 개의 데이터 요소를 포함합니다. 따라서 배열과 구조체 같은 데이터 구조는 메모리에 저장됩니다.

위에서 설명한 것처럼, MIPS 명령어에서는 산술 연산이 레지스터에서만 수행됩니다. 따라서 MIPS는 메모리와 레지스터 간 데이터를 전송하는 명령어를 포함해야 합니다. 이러한 명령어를 **데이터 전송 명령어**(data transfer instructions)라고 합니다.

메모리의 단어(word)에 접근하려면, 명령어가 메모리 주소를 제공해야 합니다. 메모리는 단일 차원의 큰 배열과 같으며, 주소는 배열의 인덱스 역할을 하며 0부터 시작합니다.

메모리에서 데이터를 레지스터로 복사하는 데이터 전송 명령어는 전통적으로 **로드**(load)라고 불립니다. 로드 명령어의 형식은 연산 이름 뒤에 데이터를 로드할 레지스터, 그리고 메모리에 접근하기 위해 사용되는 상수와 레지스터가 옵니다. 명령어의 상수 부분과 두 번째 레지스터의 내용의 합이 메모리 주소를 형성합니다. 이 명령어의 실제 MIPS 이름은 **lw**로, 이는 **load word**를 의미합니다.

lw 명령어의 형식은 다음과 같습니다.
```
lw $레지스터, 상수(기준 레지스터)
```


### 변수와 메모리 할당에 대한 컴파일러의 역할

컴파일러는 변수를 레지스터에 할당하는 것 외에도, 배열(array)과 구조체(structure)와 같은 데이터 구조를 메모리의 특정 위치에 할당합니다. 이후 컴파일러는 데이터 전송 명령어에 적절한 시작 주소를 삽입할 수 있습니다.

8비트 바이트(byte)는 많은 프로그램에서 유용하기 때문에, 오늘날 거의 모든 아키텍처는 개별 바이트를 주소로 지정합니다. 따라서 하나의 단어(word)의 주소는 해당 단어를 구성하는 4개의 바이트 중 하나의 주소와 일치하며, 연속적인 단어의 주소는 4씩 차이가 납니다. 예를 들어, **그림 2.3**은 **그림 2.2**에 있는 단어들의 실제 MIPS 주소를 보여줍니다. 여기서 세 번째 단어의 바이트 주소는 8입니다.

MIPS에서는 단어가 반드시 4의 배수인 주소에서 시작해야 합니다. 이러한 요구사항을 **정렬 제약(alignment restriction)**이라고 하며, 많은 아키텍처에서 이를 따릅니다. (4장에서 정렬이 데이터 전송 속도를 왜 향상시키는지에 대한 설명이 나옵니다.) 컴퓨터는 단어 주소로 "왼쪽 끝 바이트(big end)"를 사용하는 아키텍처와 "오른쪽 끝 바이트(little end)"를 사용하는 아키텍처로 나뉩니다. MIPS는 **빅 엔디안(big-endian)** 방식을 사용합니다. 하지만 동일한 데이터를 단어와 4개의 바이트로 모두 접근하지 않는 한, 엔디안 방식은 대부분의 경우 중요하지 않습니다. (부록 A에서는 단어 내 바이트를 번호 매기는 두 가지 방식을 보여줍니다.)

### 바이트 주소 지정과 배열 인덱스의 관계

바이트 주소 지정은 배열 인덱스에도 영향을 미칩니다. 위 코드에서 올바른 바이트 주소를 얻으려면, 기준 레지스터 **$s3**에 추가할 오프셋(offset)은 $4 \times 8$ 또는 32여야 합니다. 이렇게 해야 로드(load) 명령어가 **A[8]**을 선택하며, **A[8/4]**를 선택하지 않게 됩니다. (관련된 실수는 **2.19절** 160페이지에 나와 있습니다.)

### 로드(load) 명령어의 보완: 스토어(store) 명령어

로드 명령어와 상보적인 명령어는 전통적으로 **스토어(store)**라고 불리며, 이는 데이터를 레지스터에서 메모리로 복사합니다. 스토어 명령어의 형식은 로드 명령어와 유사합니다. 즉, 연산의 이름, 저장할 레지스터, 배열 요소를 선택하기 위한 오프셋, 그리고 기준 레지스터(base register)의 순서로 구성됩니다. MIPS 주소는 다시 한 번 상수와 레지스터의 값으로 지정됩니다. 실제 MIPS 명령어 이름은 **sw(store word)**입니다.