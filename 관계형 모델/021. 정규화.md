사전적 정의에 따르면, 정규화라는 용어는 무언가를 표준에 맞추거나 스타일과 내용에 일관성을 도입하는 것을 의미합니다. 관계형 데이터베이스 모델링에서는 이러한 일관성이 데이터 중복 제거 과정을 포함합니다. 중복 제거는 일반적으로 불필요한 데이터가 특정 장소나 테이블에 존재하지 않도록 하여 중복성을 최소화합니다.

실제로 정규화는 정보를 더 작고 관리하기 쉬운 부분으로 나누는 과정을 포함하며, 너무 작게 나누지 않는 것이 바람직합니다. 가장 명백한 중복은 대개 모든 것을 너무 수학적으로 접근하지 않아도 제거할 수 있습니다. 상업적으로 주요 목표는 공간을 절약하고 데이터의 사용성과 관리성을 조직화하는 것이며, 성능을 희생하지 않는 것입니다. 이 모든 것은 종종 균형을 맞추는 작업이며, 일반적으로 시행착오를 통해 부분적으로 해결됩니다. 또한, 매우 바쁜 응용 프로그램과 최종 사용자 요구 사항은 성능 요구를 충족하기 위해 여러 가지 방식으로 정규화 규칙을 깨야 할 필요가 있을 수 있습니다. 규칙은 일반적으로 가능한 모든 정규화 단계를 적용하지 않음으로써 깨집니다. 3차 정규형 이상의 정규형은 종종 무시되며, 때로는 3차 정규형 자체도 무시됩니다.

정규화는 세분화 도입, 중복 제거, 중복성 최소화 또는 단순히 테이블 도입으로 설명될 수 있으며, 이는 모두 데이터를 더 잘 조직된 상태로 만듭니다.

정규화는 점진적인 과정입니다. 즉, 각 정규형 단계는 이미 적용된 정규형에 추가됩니다. 예를 들어, 2차 정규형은 1차 정규형에 있는 테이블에만 적용할 수 있으며, 3차 정규형은 2차 정규형에 있는 테이블에만 적용할 수 있습니다. 각 정규형은 이전 정규형의 정제된 형태입니다. 마찬가지로, 3차 정규형은 4차 정규형에 있는 테이블에 적용할 수 없습니다. 왜냐하면 정의상 4차 정규형에 있는 테이블은 누적적으로 이미 3차 정규형에 있기 때문입니다.

## 정규화의 각 단계
### 제1정규형(1NF)

제1정규형은 반복되는 그룹을 제거하고, 모든 레코드가 기본 키에 의해 고유하게 식별될 수 있도록 보장하는 단계입니다. 즉, 테이블 내 모든 필드가 기본 키에 종속되어야 합니다. 이를 통해 데이터의 중복을 줄이고, 테이블의 구조를 간소화할 수 있습니다.

1NF는 다음과 같은 규칙을 따릅니다:

1. **반복 그룹 제거**: 테이블 내에서 반복되는 데이터를 제거하고, 이를 별도의 테이블로 분리합니다. 이를 통해 데이터의 중복을 최소화합니다.
    
2. **기본 키 정의**: 각 테이블은 고유한 기본 키를 가져야 하며, 이를 통해 모든 레코드를 고유하게 식별할 수 있어야 합니다. 기본 키는 중복 값을 허용하지 않습니다.
    
3. **기본 키에 종속**: 모든 필드는 기본 키에 직접적 또는 간접적으로 종속되어야 합니다. 이는 데이터의 무결성을 보장하는 데 필수적입니다.
    
4. **단일 값 유지**: 모든 필드는 단일 값을 가져야 하며, 여러 값이 하나의 필드에 저장되어서는 안 됩니다.
    
5. **동일한 데이터 타입**: 각 필드 내의 모든 값은 동일한 데이터 타입을 가져야 합니다.
    
6. **새로운 테이블 생성**: 반복 그룹을 원본 테이블에서 분리하여 새로운 테이블로 이동시킵니다. 이를 통해 테이블 간의 관계를 명확히 하고, 데이터의 중복을 줄입니다.

### 제2정규형(2NF)

제2정규형에서는 모든 비키(non-key) 값이 기본 키에 완전히 함수적으로 종속되도록 합니다. 부분 종속성을 제거하는 것이 핵심입니다. 부분 종속성은 필드가 복합 기본 키의 일부에만 종속되는 경우를 말합니다. 이를 해결함으로써 데이터의 일관성을 높일 수 있습니다.

2NF는 다음과 같은 규칙을 따릅니다:

1. **1NF 만족**: 2NF를 적용하기 위해서는 테이블이 이미 1NF를 만족해야 합니다. 즉, 반복 그룹이 제거되고, 모든 필드가 기본 키에 종속되어 있어야 합니다.
    
2. **완전 함수 종속성**: 모든 비키(non-key) 필드는 기본 키에 완전히 함수적으로 종속되어야 합니다. 즉, 비키 필드가 기본 키의 일부에만 종속되는 경우는 허용되지 않습니다.
    
3. **부분 종속성 제거**: 부분 종속성은 복합 기본 키의 일부에만 종속되는 비키 필드를 의미합니다. 이를 제거하여, 비키 필드가 기본 키 전체에 종속되도록 해야 합니다.
    
4. **새로운 테이블 생성**: 부분적으로 종속된 필드와 그 필드가 종속된 기본 키의 일부를 분리하여 새로운 테이블로 이동시킵니다. 이를 통해 테이블 간의 관계를 명확히 하고, 데이터의 중복을 줄입니다.

### 제3정규형(3NF)

제3정규형은 이행적 종속성을 제거하는 단계입니다. 이행적 종속성은 한 필드가 기본 키가 아닌 다른 필드에 종속되어 있는 경우를 의미합니다. 이 단계에서는 필드가 기본 키에 직접적으로 종속되도록 하여 데이터의 무결성을 강화합니다.

3NF는 다음과 같은 규칙을 따릅니다:

1. **2NF의 충족:**
    - 3NF로 전환하기 전에 테이블은 반드시 제2정규형(2NF)을 만족해야 합니다. 이는 모든 비주요 속성이 기본 키에 완전 함수적 종속이어야 함을 의미합니다.
    
2. **이행적 종속의 제거:**
    - 3NF의 핵심은 이행적 종속을 제거하는 것입니다. 이행적 종속이란, 한 속성이 기본 키에 직접적으로 종속되지 않고 다른 속성을 통해 간접적으로 종속되는 경우를 말합니다.
    - 예를 들어, 속성 A가 B에 종속되고, B가 기본 키에 종속된다면, A는 기본 키에 이행적 종속을 갖고 있다고 할 수 있습니다.
    
3. **모든 비주요 속성의 직접적 종속:**
    - 테이블 내 모든 비주요 속성은 기본 키에 직접적으로 종속되어야 합니다. 이는 비주요 속성이 다른 비주요 속성을 통해서가 아니라 기본 키를 통해 결정되어야 함을 의미합니다.

#### 3NF의 실질적 적용

- **테이블 구조의 변화:**
    - 3NF를 적용하면 종종 새로운 테이블이 생성됩니다. 이는 데이터의 이행적 종속을 제거하고 각 테이블이 명확한 목적과 관계를 가지도록 하기 위함입니다.

- **데이터베이스 크기의 감소:**
    - 중복된 데이터를 제거함으로써 데이터베이스의 전체 크기가 감소합니다. 이는 저장 공간의 효율성을 높이고 데이터 관리의 복잡성을 줄입니다.

- **복잡한 쿼리의 가능성:**
    - 다수의 테이블로 나뉘면서 쿼리가 복잡해질 수 있습니다. 이는 성능에 영향을 미칠 수 있지만, 데이터의 무결성을 보장하고 유지보수성을 높이는 데 유리합니다. 성능상의 이유로 때때로 비정규화(denormalization)를 고려할 수도 있습니다.

### 3NF를 넘어서는 정규화

데이터베이스 정규화는 데이터의 중복을 줄이고 무결성을 유지하기 위한 중요한 과정입니다. 그러나 제3정규형(3NF)을 넘어서는 정규화는 복잡성과 성능 문제를 초래할 수 있습니다.

1. **복잡성 증가:**
    - 3NF를 넘어서는 정규화는 데이터베이스 구조를 지나치게 세분화하여 복잡성을 증가시킬 수 있습니다. 이는 많은 테이블을 생성하게 되고, 복잡한 SQL 조인을 필요로 하며, 결과적으로 데이터베이스 응답 시간을 저하시킬 수 있습니다.
    
2. **성능 문제:**
    - 지나친 정규화는 데이터베이스 성능에 부정적인 영향을 미칠 수 있습니다. 테이블의 수가 많아지면, 쿼리의 조인 연산이 복잡해지고, 이는 성능 저하로 이어질 수 있습니다.
    
3. **상업적 환경에서의 비효율성:**
    - 상업적 환경에서는 데이터베이스 모델의 완벽함보다는 효율성과 비용 효과성이 더 중요합니다. 지나친 정규화는 실질적인 이익을 가져오기보다는 관리의 복잡성만 증가시킬 수 있습니다.

### 보이스-코드 정규형(BCNF)

보이스-코드 정규형은 테이블의 모든 결정자가 후보 키가 되도록 하는 단계입니다. 이는 제3정규형의 확장으로, 모든 결정자가 후보 키가 되어야 한다는 점에서 차이가 있습니다. 이 단계는 데이터베이스의 구조적 문제를 더욱 철저하게 해결합니다.

BCNF는 다음과 같은 규칙을 따릅니다:

1. **3NF의 충족:**
    - BCNF로 전환하기 위해서는 테이블이 먼저 3NF를 만족해야 합니다. 이는 모든 비주요 속성이 기본 키에 직접적으로 종속되어야 함을 의미합니다.
    
2. **단일 후보 키:**
    - BCNF는 테이블이 단 하나의 후보 키만을 가져야 한다고 요구합니다. 후보 키는 테이블의 기본 키가 될 잠재력을 가진 속성으로, 테이블 내의 레코드를 고유하게 식별할 수 있습니다.
    
3. **결정자와 후보 키:**
    - BCNF는 테이블 내의 모든 결정자가 후보 키가 되어야 한다고 규정합니다. 결정자는 다른 속성의 값을 결정하는 역할을 하는 속성입니다. 따라서, 모든 결정자가 후보 키여야 한다는 것은 테이블 내의 모든 결정자가 고유하게 식별 가능해야 함을 의미합니다.

### 제4정규형(4NF)

제4정규형에서는 다중 값 종속성을 제거합니다. 이는 한 필드가 여러 값의 집합을 가질 수 있는 경우를 해결하는 단계입니다. 다중 값 종속성을 제거함으로써 데이터의 중복을 최소화하고, 데이터베이스의 무결성을 유지합니다.

4NF는 다음과 같은 규칙을 따릅니다:

1. **3NF 또는 BCNF의 충족:**
    - 4NF로 전환하기 위해서는 테이블이 먼저 3NF 또는 BCNF를 만족해야 합니다. 이는 기본적인 정규화 조건을 충족해야 함을 의미합니다.
    
2. **다중 값 종속성의 제거:**
    - 4NF는 다중 값 종속성을 함수적 종속성으로 변환할 것을 요구합니다. 이는 기본 키에 대해 하나의 값만이 종속되어야 하며, 여러 값이 종속되어서는 안 된다는 것을 의미합니다.
    
3. **비자명 다중 값 종속성의 제거:**
    - 비자명 다중 값 종속성을 제거해야 합니다. 이는 하나의 속성이 다른 속성 집합에 종속될 때 발생하는 중복을 방지하기 위한 것입니다.

### 제5정규형(5NF)

제5정규형은 순환 종속성을 제거하는 단계로, 이는 필드 간의 의존 관계가 순환 구조를 이루는 경우를 해결합니다. 제5정규형은 데이터베이스의 복잡한 의존성을 해결하고, 데이터의 일관성을 유지하는 데 중점을 둡니다.

5NF는 다음과 같은 규칙을 따릅니다:

1. **4NF의 충족:**
    - 5NF로 전환하기 위해서는 테이블이 먼저 4NF를 만족해야 합니다. 이는 다중 값 종속성이 제거된 상태여야 함을 의미합니다.
    
2. **순환 종속성의 제거:**
    - 5NF는 순환 종속성을 제거해야 합니다. 순환 종속성은 하나의 속성이 다른 속성에 직접적 또는 간접적으로 종속되어 있는 경우를 말하며, 이는 데이터베이스의 무결성을 저해할 수 있습니다.
    
3. **프로젝션 정규형(PJNF):**
    - 5NF는 프로젝션 정규형이라고도 불리며, 이는 원본 테이블의 데이터 하위 집합을 포함하는 새로운 테이블을 생성하는 과정을 의미합니다.


#### 7. 도메인-키 정규형(DKNF)

도메인-키 정규형은 정규화의 궁극적인 형태로, 개념적 상태의 측정으로 볼 수 있습니다. 이는 변환 과정보다는 데이터베이스 설계의 이상적인 상태를 나타냅니다.

DKNF는 다음과 같은 규칙을 따릅니다:

1. **삽입, 변경, 삭제 이상 현상의 제거:**
    - DKNF는 데이터베이스에서 삽입, 변경, 삭제 시 발생할 수 있는 모든 이상 현상을 제거하는 것을 목표로 합니다. 즉, 데이터베이스의 모든 레코드는 오류 없이 직접적으로 접근 가능해야 합니다.
    
2. **고유 식별성:**
    - 데이터베이스의 모든 테이블에 있는 모든 레코드는 고유하게 식별 가능해야 하며, 테이블의 기본 키와 직접적으로 관련되어야 합니다. 이는 테이블의 모든 필드가 해당 테이블의 기본 키에 의해 직접 결정되어야 함을 의미합니다.
    
3. **데이터 검증의 내재화:**
    - 데이터 검증은 데이터베이스 모델 내에서 이루어져야 합니다. 이는 데이터베이스와 응용 프로그램 간의 기능을 분리하여 처리하는 것이 일반적으로 더 효율적입니다.

#### DKNF의 이상적 측면과 실용적 고려사항

1. **수학적 완전성:**
    - DKNF는 수학적으로 완벽한 정규화 형태로, 그 단순성과 세부적인 완전성에서 아름다움을 찾을 수 있습니다. 이는 객체 지향 데이터베이스 모델에서 특히 잘 맞으며, 개별 데이터 항목이 고유한 요소로만 접근되는 경우에 적합합니다.
    
2. **상업적 환경에서의 도전 과제:**
    - 상업적인 관계형 데이터베이스 모델에서는 DKNF 수준의 정규화가 데이터베이스 및 응용 프로그램 성능에 부정적인 영향을 미칠 수 있습니다. 이는 범위 검색과 보고를 요구하는 대부분의 상업적 데이터베이스에서 일반적으로 발생하는 문제입니다.
    
3. **사용자 만족도:**
    - 응용 프로그램의 궁극적인 목표는 사용자 만족도입니다. DKNF는 이론적으로 이상적인 형태일 수 있지만, 실제로는 사용자 경험을 저해할 수 있는 성능 문제를 초래할 수 있습니다. 따라서, 데이터베이스 설계자는 DKNF를 목표로 하되, 실용적인 성능과 사용자 요구를 균형 있게 고려해야 합니다.

## 정규화의 이점

중복성을 효과적으로 최소화하는 것은 중복 제거를 설명하는 또 다른 방법입니다. 중복 제거의 효과는 다음과 같습니다:

- 데이터를 저장하는 데 필요한 물리적 공간이 줄어듭니다.
- 데이터가 더 잘 조직됩니다.
- 정규화는 소량의 데이터(즉, 단일 레코드)를 한 번에 한 테이블에서 변경할 수 있게 합니다. 즉, 데이터베이스에서 특정 항목이 추가되거나 변경되거나 제거될 때 단일 테이블 레코드가 업데이트됩니다. 단일 레코드의 단일 필드 값을 변경하기 위해 전체 데이터베이스를 검색할 필요 없이 테이블만 수정하면 됩니다.

## 정규화의 잠재적 위험

이 중복성 최소화 과정을 지나치게 진행하면 잠재적인 문제가 발생할 수 있습니다. 앞서 언급한 정규화의 긍정적 효과의 일부 세부 사항은 응용 프로그램의 초점에 따라 부정적인 부작용을 가질 수 있으며, 때로는 역효과를 낼 수도 있습니다. 성능은 정규화의 과도한 적용으로 인한 지나친 세분화로 항상 문제가 됩니다. 매우 높은 동시성을 요구하는 OLTP 데이터베이스는 지나친 세분화로 인해 매우 부정적인 영향을 받을 수 있습니다. 데이터 웨어하우스는 종종 비기술적인 최종 사용자 접근을 필요로 하며, 지나친 세분화는 테이블 구조를 너무 기술적으로 만들어 최종 사용자가 해석하기 어렵게 만듭니다. 다음 사항을 염두에 두세요:

- 물리적 공간은 이전만큼 큰 문제가 아닙니다. 디스크 공간은 고려해야 할 비용 요소 중 가장 저렴한 것 중 하나입니다(물론, 정말 거대한 데이터 웨어하우스를 다루는 경우는 제외).
- 중복성을 지나치게 최소화하면 지나친 세분화와 너무 많은 테이블이 생깁니다. 너무 많은 테이블은 매우 큰 SQL 조인 쿼리를 초래할 수 있습니다. SQL 조인 쿼리에 테이블이 많을수록 쿼리 실행 속도가 느려집니다. 성능이 너무 심각하게 영향을 받아 응용 프로그램이 완전히 쓸모없게 될 수 있습니다.
- 중복성을 극도로 최소화하여 데이터를 더 잘 조직하면 실제로 더 복잡해질 수 있습니다. 특히 최종 사용자가 데이터베이스 모델 구조에 노출되는 경우 그렇습니다. 정규화 수준이 깊어질수록 모델이 더 수학적으로 되어 "기술 친화적"이지만 "사용자 친화적"이지 않게 됩니다. 데이터베이스에 접근하는 사람이 최종 사용자입니까, 아니면 OLTP 응용 프로그램입니까?