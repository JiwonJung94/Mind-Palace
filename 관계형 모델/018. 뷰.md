뷰는 데이터베이스 내에서 정의된 가상 테이블로, 실제 데이터를 저장하지 않고 다른 테이블의 데이터를 참조하여 생성됩니다. 뷰의 주요 목적은 다음과 같습니다:

1. **데이터 접근의 간소화**: 뷰를 사용하면 복잡한 쿼리를 단순화하여 사용자가 쉽게 데이터를 접근할 수 있게 됩니다. 이는 특히 반복적으로 사용되는 복잡한 쿼리를 간단한 뷰로 정의하여 활용할 때 매우 유용합니다.

2. **논리적 데이터 독립성 제공**: 뷰는 논리적 데이터 독립성을 지원합니다. 이는 데이터의 논리적 구조가 변경되더라도 사용자에게 제공되는 데이터의 형태는 변하지 않도록 보장하는 것입니다. 예를 들어, 기존의 테이블을 두 개의 새로운 테이블로 분할하더라도, 뷰를 통해 이전과 동일한 방식으로 데이터를 접근할 수 있습니다.

논리적 데이터 독립성(Logical Data Independence)은 데이터베이스 관리 시스템(DBMS)에서 중요한 개념으로, 데이터의 논리적 구조가 변경되더라도 사용자에게 제공되는 데이터의 형식이나 접근 방식은 변하지 않도록 하는 것입니다. 뷰는 이러한 논리적 데이터 독립성을 제공함으로써, 데이터베이스의 구조적 변경이 사용자에게 미치는 영향을 최소화합니다.

뷰는 특정 시점에 특정 관계 표현식을 평가한 결과로 정의됩니다. 뷰를 정의할 때 사용되는 표현식은 최소한 하나의 관계 변수를 포함해야 합니다. SQL에서는 뷰가 테이블로 간주됩니다. 이는 뷰와 테이블이 본질적으로 동일하다는 것을 의미하며, 뷰는 단지 데이터베이스에 저장된 쿼리의 결과일 뿐입니다. SQL 문서에서는 "테이블과 뷰"라는 표현을 사용하여 이 둘이 다른 것처럼 보일 수 있지만, 사실 뷰는 테이블의 한 형태입니다.


### 뷰의 개념적 이해

1. **가상 관계 변수(Virtual Relvar)**: 뷰는 가상 관계 변수로 이해될 수 있습니다. 이는 기본 관계 변수처럼 보이고 작동하지만, 독립적으로 존재하지 않고 다른 관계 변수를 기반으로 정의됩니다.
    
2. **유도 관계 변수(Derived Relvar)**: 뷰는 유도된 관계 변수로 볼 수 있습니다. 이는 특정 다른 관계 변수들로부터 명시적으로 유도된 관계 변수입니다. 모든 가상 관계 변수는 유도된 것이지만, 모든 유도된 관계 변수가 가상 관계 변수인 것은 아닙니다.
    
3. **관계 변수에 대한 창(Window)**: 뷰는 유도된 관계 변수들에 대한 창으로, 뷰에 대한 연산은 실제로는 이러한 기본 관계 변수들에 대한 연산으로 이해됩니다.
    
4. **정형화된 쿼리(Canned Query)**: 뷰는 흔히 정형화된 쿼리로 불리며, 이는 이름이 붙은 관계 표현식이라고 할 수 있습니다.

### 뷰의 장점

- **데이터 추상화**: 뷰는 사용자에게 데이터의 복잡성을 숨기고 단순화된 인터페이스를 제공합니다.
- **보안**: 뷰를 통해 사용자가 접근할 수 있는 데이터 범위를 제한할 수 있습니다.
- **재사용성**: 동일한 쿼리를 반복해서 작성할 필요 없이 뷰를 통해 재사용할 수 있습니다.

### 뷰와 스냅샷의 차이

뷰와 스냅샷은 둘 다 파생 릴레이션 변수(derived relvar)이지만, 중요한 차이점이 있습니다:

- **뷰(View)**: 뷰는 가상 테이블로, 실제 데이터를 저장하지 않습니다. 뷰에 대한 연산은 기본 테이블에 대한 연산으로 변환되어 수행됩니다. 따라서 뷰는 데이터의 실시간 상태를 반영합니다.
    
- **스냅샷(Snapshot)**: 스냅샷은 특정 시점의 데이터를 저장한 실제 테이블입니다. 이는 주기적으로 갱신되며, 그 사이에는 데이터가 변경되지 않습니다. 스냅샷은 데이터 웨어하우스나 분산 시스템에서 과거 시점의 데이터를 필요로 할 때 유용합니다.
    

스냅샷은 종종 "물리적 뷰(Materialized View)"로 불리기도 하지만, 이는 용어의 혼동을 초래할 수 있습니다. 뷰는 본래 물리적으로 저장되지 않기 때문에, "물리적 뷰"라는 용어는 모순적입니다. 따라서, "뷰"라는 용어를 사용할 때는 그 의미를 명확히 하는 것이 중요합니다.


## 교환 가능성 원칙

교환 가능성 원칙은 기본 관계 변수와 가상 관계 변수 사이에 불필요한 구분이 없어야 한다는 개념입니다. 데이터베이스 설계에서 뷰(View)는 가상 관계 변수(Virtual Relvar)로, 기본 관계 변수(Base Relvar)와 동일한 역할을 수행할 수 있습니다. 즉, 사용자 관점에서 뷰는 기본 관계 변수처럼 "보이고 느껴져야" 합니다. 이 원칙은 데이터베이스 설계 시 뷰와 기본 테이블의 역할을 서로 바꿀 수 있어야 한다는 점을 강조합니다.

가장 중요한 것은 뷰가 갱신 가능해야 한다는 점입니다. 만약 뷰가 갱신 불가능하다면, 이는 교환 가능성 원칙을 명백히 위반하는 것입니다. 뷰가 갱신 불가능하다고 여겨지는 주된 이유 중 하나는 무결성 제약 조건의 위반 가능성입니다. 그러나 이 문제는 기본 관계 변수에서도 동일하게 발생할 수 있습니다. 뷰는 기본 관계 변수처럼 무결성 제약을 받을 수 있으며, 이는 뷰에도 키(Key)와 외래 키(Foreign Key)를 정의할 수 있음을 의미합니다. 따라서 다른 테이블이 뷰를 참조할 수 있어야 하며, 이는 뷰가 기본 테이블과 동일한 수준의 무결성과 기능성을 가져야 한다는 것을 의미합니다.

예를 들어, 두 개의 기본 릴레이션 변수 S와 P가 CITY 속성을 기준으로 조인된 뷰 S JOIN P가 있다고 가정해봅시다. 일반적으로 이러한 뷰에 튜플을 삽입하거나 삭제하는 것이 불가능하다고 생각할 수 있습니다. 이는 뷰가 여러 테이블의 데이터를 포함하고 있어 무결성 제약 조건을 위반할 가능성이 있다고 판단하기 때문입니다. 그러나 이는 잘못된 가정입니다. 기본 릴레이션 변수에서도 특정 업데이트가 무결성 제약 조건 위반으로 실패할 수 있습니다. 즉, 뷰와 기본 릴레이션 변수 모두에서 업데이트가 실패할 수 있는 상황은 존재합니다. 따라서, 뷰가 갱신 가능해야 한다는 요구는 단순한 이상이 아니라, 관계형 데이터베이스의 일관성 있는 설계를 위한 필수 조건입니다. 이를 통해 뷰는 기본 테이블과 동일한 수준의 유연성과 기능성을 제공해야 하며, 이는 교환 가능성 원칙을 준수하는 데 필수적입니다.

관계형 데이터베이스에서 뷰(View)는 기본 테이블처럼 작동할 수 있어야 합니다. 이를 가능하게 하는 중요한 개념 중 하나가 바로 관계형 폐쇄성(Closure Property)입니다. 이 속성 덕분에, 우리는 변수의 이름을 그 값으로 대체할 수 있습니다. 즉, SQL 쿼리에서 테이블 이름을 보다 일반적인 SQL 테이블 표현식으로 바꿀 수 있으며, 이는 뷰의 이름을 뷰를 정의하는 표현식으로 대체할 수 있음을 의미합니다. 이러한 특성은 사용자가 뷰를 통해 복잡한 데이터 구조를 보다 쉽게 다룰 수 있도록 해줍니다.

하지만 초기 SQL 버전에서는 이러한 관계형 폐쇄성을 완전히 지원하지 않았습니다. 이로 인해 뷰에 대한 대체 절차가 항상 제대로 작동하지 않았고, 결과적으로 특정 쿼리가 실패하는 경우가 발생했습니다. 이러한 문제는 SQL:1992 표준에서 해결되었지만, 모든 데이터베이스 시스템이 이 표준을 따르지는 않았습니다. 따라서 일부 시스템에서는 여전히 뷰를 물리적으로 구현하는 방식을 사용합니다. 즉, 뷰 정의 표현식을 평가하여 결과를 저장한 후, 그 결과에 대해 쿼리를 수행하는 방식입니다. 이러한 접근 방식은 관계형 모델의 본래 의도와는 다를 수 있으며, 성능 면에서도 최적이 아닐 수 있습니다.

### 엔터티 무결성 규칙의 문제

엔터티 무결성(Entity Integrity) 규칙은 관계형 데이터베이스에서 각 테이블의 주 키(Primary Key)가 null을 가질 수 없도록 보장하는 중요한 제약 조건입니다. 이는 데이터베이스 내에서 각 레코드를 고유하게 식별할 수 있게 하여 데이터의 일관성을 유지하는 데 필수적입니다. 그러나 이 규칙은 주로 기본 테이블에 적용되고 있으며, 뷰에는 적용되지 않는 경우가 많습니다. 이러한 차이는 뷰가 기본 테이블처럼 작동할 수 있어야 한다는 교환 가능성 원칙을 위반하게 합니다.

또한, 엔터티 무결성은 주로 Primary key에 집중하지만, 뷰가 여러 테이블을 조합하여 생성될 경우 특정 필드 조합이 고유해야 하는 상황이 발생할 수 있습니다. 이럴 때는 일반적인 키(Unique Key)에도 유사한 무결성 제약이 필요할 수 있습니다. 따라서, 뷰가 기본 테이블과 동일한 수준의 무결성을 제공할 수 있도록 설계하는 것이 중요합니다. 이는 교환 가능성 원칙을 지키는 데 도움을 줄 수 있으며, 데이터베이스의 일관성과 신뢰성을 높이는 데 기여합니다.

### SQL의 Row ID 문제

많은 SQL 제품과 표준은 "Row ID" 기능을 제공합니다. 이 기능이 기본 테이블에는 적용되지만 뷰에는 적용되지 않는다면, 이는 교환 가능성 원칙을 위반하게 됩니다. Row ID는 관계형 모델의 일부가 아니며, 객체 지향의 개념인 객체 ID(Object ID)로 간주될 경우 명백히 금지됩니다. 객체 ID는 사실상 포인터이며, 관계형 모델은 포인터를 명시적으로 금지하고 있습니다.


## 뷰의 술어

뷰의 술어는 파생 술어(Derived Predicate)로, 이는 뷰가 정의되는 기본 테이블의 술어와 뷰 정의에 포함된 관계 연산의 의미를 기반으로 만들어집니다. 쉽게 말해, 뷰의 정의는 기본 테이블의 술어와 뷰 정의 표현식의 논리적 조합으로부터 유도됩니다.

뷰의 제약 조건은 뷰를 구성하는 기본 테이블의 제약 조건과 뷰 정의에 사용된 관계 연산의 의미를 바탕으로 형성됩니다. 예를 들어, 뷰가 기본 테이블의 일부 데이터를 특정 조건으로 필터링하여 생성된다면, 그 뷰의 술어는 기본 테이블의 술어와 이 필터링 조건이 결합된 형태가 됩니다. 즉, 뷰의 제약 조건은 해당 뷰가 정의된 기본 테이블과 그 조건들로부터 논리적으로 도출됩니다. 이는 뷰가 관계형 연산을 통해 어떻게 구성되는지를 이해하는 데 중요한 역할을 합니다.

또한, 뷰의 술어 매개변수는 뷰의 속성과 직접적으로 연결됩니다. 특정 속성이 항상 동일한 값을 가진다면, 그 속성은 매개변수가 아닌 상수로 간주될 수 있습니다. 예를 들어, 뷰가 항상 특정 도시의 정보를 포함한다면, 그 도시는 상수로 취급될 수 있습니다. 이는 뷰 정의에서 해당 속성을 제거하여 구조를 단순화할 수 있는 근거가 되기도 합니다. 이러한 방식으로, 뷰는 기본 테이블처럼 작동하면서도 필요에 따라 속성을 추가하거나 제거하여 복잡성을 줄일 수 있습니다.

명시적인 제약 조건 선언은 뷰의 가독성과 유지보수성을 높이는 데 큰 도움이 됩니다. SQL에서는 뷰 정의에 직접 제약 조건을 포함할 수는 없지만, CREATE ASSERTION을 사용하여 논리적으로 동일한 제약 조건을 정의할 수 있습니다. 시스템이 자동으로 제약 조건을 유추할 수 없는 경우, 명시적인 선언은 사용자에게 뷰의 의미를 명확히 전달하는 데 유용합니다. 그러나 이러한 명시적 선언은 중복 검사를 초래할 수 있으므로, 시스템 성능을 고려하여 중복 검사를 피할 방법을 모색하는 것이 중요합니다.
