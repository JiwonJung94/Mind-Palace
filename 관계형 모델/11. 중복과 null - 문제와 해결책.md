SQL 데이터베이스를 설계하고 사용할 때, 중복된 행과 null은 종종 논란의 대상이 됩니다. 이러한 요소들은 데이터 무결성과 효율성에 영향을 미칠 수 있으며, SQL의 최적화 및 사용자 경험에 부정적인 영향을 미칠 수 있습니다. 이번 포스트에서는 중복과 null이 왜 문제가 되는지, 그리고 이를 어떻게 해결할 수 있는지에 대해 살펴보겠습니다.

## 중복의 문제점

### 1. 데이터 무결성의 저해

관계형 데이터베이스에서 테이블은 집합(set)으로 간주되며, 집합은 중복된 요소를 허용하지 않습니다. 그러나 SQL에서는 중복된 행이 허용되며, 이는 데이터의 명확성과 일관성을 저해할 수 있습니다. 예를 들어, 동일한 데이터가 여러 번 존재한다면, 이 데이터가 의미하는 바가 명확하지 않으며, 중복된 데이터가 실제로 어떤 의미를 가지는지 불분명합니다.

### 2. 최적화의 방해

SQL 쿼리의 성능을 향상시키기 위해 데이터베이스 관리 시스템(DBMS)은 쿼리 리라이트(query rewrite)라는 최적화 기법을 사용합니다. 이는 동일한 결과를 생성하지만 더 효율적인 쿼리로 변환하는 과정입니다. 그러나 중복이 존재하면 이러한 최적화가 방해받을 수 있습니다. 중복된 행은 쿼리의 다양한 표현이 서로 다른 결과를 초래할 수 있게 하며, 이는 최적화의 자유도를 제한합니다.

### 3. 오류 탐지의 어려움

중복된 행이 허용되는 경우, 데이터 입력 오류로 인해 발생한 중복과 실제로 의미 있는 중복을 구분하기 어렵습니다. 예를 들어, 동일한 데이터를 실수로 두 번 입력한 경우, 이를 수정하기 위한 방법이 명확하지 않을 수 있습니다.

## null의 문제점

### 1. 세 가지 논리 값(3VL)의 복잡성

SQL에서는 null을 처리하기 위해 세 가지 논리 값(3VL)을 사용합니다: TRUE, FALSE, UNKNOWN. 이는 전통적인 이진 논리(2VL)와 달리, null이 포함된 비교 연산이 UNKNOWN으로 평가될 수 있음을 의미합니다. 예를 들어, `A > B` 비교에서 A나 B가 null이면 결과는 UNKNOWN입니다. 이러한 세 가지 논리 값 체계는 쿼리 결과의 예측 가능성을 떨어뜨리고, 데이터베이스의 무결성을 해칠 수 있습니다.

### 2. 쿼리 결과의 신뢰성 문제

null이 포함된 데이터베이스에서 쿼리를 실행할 때, 쿼리 결과가 실제 세계의 기대와 다를 수 있습니다. 예를 들어, 특정 조건문이 null 때문에 TRUE로 평가되지 않아 예상치 못한 결과를 초래할 수 있습니다. 이는 쿼리 결과의 신뢰성을 저하시킬 뿐만 아니라, 사용자가 잘못된 결론을 내리게 할 수 있습니다.

### 3. 데이터 구조의 왜곡

null은 본질적으로 값이 아니기 때문에, null을 포함하는 데이터 구조는 그 자체로 불완전합니다. 예를 들어, null을 포함하는 튜플은 완전한 튜플이 아니며, null을 포함하는 관계는 완전한 관계가 아닙니다. 이는 데이터 모델링의 기본 원칙을 위배하며, 데이터베이스의 일관성을 해칠 수 있습니다.



# SQL에서 중복 방지하기

SQL에서 중복된 데이터는 데이터 무결성을 해치고 쿼리 성능에 영향을 미칠 수 있습니다. 관계형 모델에서는 중복을 허용하지 않으므로, SQL을 관계형으로 사용하기 위해서는 중복을 방지하기 위한 조치를 취해야 합니다. 이번 포스트에서는 SQL에서 중복이 발생할 수 있는 경우와 이를 방지하는 방법에 대해 설명하겠습니다.

## SQL에서 중복이 발생할 수 있는 경우

1. **SELECT ALL**: `SELECT` 문에서 `ALL` 키워드를 사용하면 결과 테이블에 중복된 행이 포함될 수 있습니다. 이는 기본적으로 모든 행을 반환하기 때문입니다.

2. **UNION ALL**: `UNION ALL`은 두 개의 쿼리 결과를 합치면서 중복된 행을 제거하지 않습니다. 따라서 중복된 데이터가 결과에 포함될 수 있습니다.

3. **VALUES**: 테이블 값을 생성할 때 사용하는 `VALUES` 구문도 중복된 데이터를 생성할 수 있습니다.

## 중복 방지를 위한 전략

### 1. DISTINCT 사용

- **SELECT 문에서**: `SELECT` 문에서 `DISTINCT` 키워드를 사용하여 중복된 행을 제거할 수 있습니다. 이는 결과 테이블의 각 행이 고유하도록 보장합니다.
  
- **집합 연산에서**: `UNION`, `INTERSECT`, `EXCEPT`와 같은 집합 연산에서는 기본적으로 `DISTINCT`가 적용됩니다. 따라서 별도로 `DISTINCT`를 지정하지 않아도 중복이 제거됩니다.

- **집합 함수에서**: `SUM`과 같은 집합 함수에서는 `ALL`이나 `DISTINCT`를 지정할 수 있습니다. 중복을 고려하지 않으려면 `DISTINCT`를 사용해야 합니다.

### 2. 중복 제거의 중요성 이해하기

SQL에서 중복을 제거하는 것이 언제 중요한지 이해하는 것이 필요합니다. 중복이 자동으로 제거되는 경우와 그렇지 않은 경우를 명확히 알고 있어야 합니다. 불필요한 중복 제거는 쿼리 성능에 영향을 줄 수 있으므로, 중복 제거가 논리적으로 필요한 경우에만 `DISTINCT`를 사용해야 합니다.

### 3. ALL 사용 피하기

가능한 한 `ALL` 키워드의 사용을 피해야 합니다. `ALL`은 중복된 데이터를 허용하므로, 데이터의 무결성을 유지하기 위해서는 `DISTINCT`를 사용하는 것이 바람직합니다.





## SQL에서 null 피하기

관계형 모델에서는 null을 허용하지 않으며, SQL을 관계형으로 사용하기 위해서는 null을 방지하기 위한 조치를 취해야 합니다. 이번 포스트에서는 SQL에서 null이 발생할 수 있는 상황과 이를 방지하는 방법에 대해 설명하겠습니다.

### SQL에서 null이 발생할 수 있는 상황

1. **집합 함수**: `SUM`, `MAX`, `MIN`과 같은 집합 함수는 인자가 비어 있을 경우 null을 반환합니다. `COUNT`와 `COUNT(*)`는 예외적으로 0을 반환합니다.

2. **스칼라 서브쿼리**: 스칼라 서브쿼리가 빈 테이블을 평가하면, 그 결과는 null로 변환됩니다.

3. **행 서브쿼리**: 행 서브쿼리가 빈 테이블을 평가하면, 그 결과는 모든 값이 null인 행으로 변환됩니다.

4. **외부 조인 및 유니온 조인**: 외부 조인과 유니온 조인은 결과에 null을 생성하도록 설계되었습니다.

5. **CASE 표현식**: `CASE` 표현식에서 `ELSE` 옵션을 생략하면, `ELSE NULL`이 기본값으로 간주됩니다.

6. **NULLIF 함수**: `NULLIF(x, y)`는 `x = y`가 TRUE로 평가될 경우 null을 반환합니다.

7. **참조 무결성 트리거**: `ON DELETE SET NULL` 및 `ON UPDATE SET NULL`은 null을 생성할 수 있습니다.

### null 방지를 위한 전략

1. **NOT NULL 제약 조건 사용**: 모든 기본 테이블의 모든 열에 대해 `NOT NULL` 제약 조건을 명시적으로 또는 암시적으로 지정하여 null의 발생을 방지합니다. 이는 데이터베이스 설계 시 가장 기본적인 단계입니다.

2. **NULL 키워드 사용 금지**: `NOT NULL` 제약 조건이나 그와 동등한 논리적 표현 외의 문맥에서 NULL 키워드를 사용하지 않도록 합니다.

3. **CASE 표현식에서 ELSE 옵션 명시**: `CASE` 표현식에서 `ELSE` 옵션을 생략하지 않도록 하여, 예상치 못한 null의 발생을 예방합니다.

4. **NULLIF 함수 사용 금지**: `NULLIF` 함수는 null을 생성할 수 있으므로 사용을 피하는 것이 좋습니다.

5. **외부 조인 사용 금지**: 외부 조인(`OUTER`, `FULL`, `LEFT`, `RIGHT`)은 null을 생성할 수 있으므로, 가능한 사용을 피합니다.

6. **COALESCE 사용**: null로 평가될 수 있는 모든 스칼라 표현식에 대해 `COALESCE`를 사용하여 null을 다른 비null으로 대체합니다. `COALESCE`는 첫 번째 비null 인자를 반환하며, 모든 인자가 null일 경우 null을 반환합니다.

