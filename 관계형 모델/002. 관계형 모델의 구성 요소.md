관계형 데이터베이스 모델은 현대 데이터 관리의 핵심 개념으로, 데이터를 체계적으로 저장하고 관리하는 데 필수적인 역할을 합니다. 이번 포스트에서는 관계형 모델을 구성하는 세 가지 요소인 구조, 무결성, 그리고 조작에 대해 살펴보겠습니다. 이를 통해 관계형 데이터베이스 모델의 기본 개념을 이해할 수 있을 것입니다.

## 구조: 테이블과 키

### 테이블

관계형 모델에서 주요 구조적 특징은 당연히 관계 그 자체이며, 일반적으로 관계를 테이블의 형태로 나타냅니다. 관계는 타입 위에 정의되며, 타입은 속성이 값을 취하는 개념적인 집합을 의미합니다. 각 테이블은 여러 열(속성)과 행(튜플)으로 구성되며, 이는 각각 n-항 관계로 이해할 수 있습니다.

### 키

관계형 모델은 다양한 종류의 키를 지원하며, 데이터의 고유성과 무결성을 보장하는 데 중요한 역할을 합니다.

우선, 모든 관계는 최소한 하나의 **후보 키**를 가져야 합니다. 후보 키는 고유 식별자로, 관계의 모든 튜플이 해당 속성 조합에 대해 고유한 값을 가지도록 보장합니다. 후보 키는 속성들의 조합으로 구성되며, 경우에 따라 하나의 속성만 포함될 수도 있습니다.

- **유일성(Uniqueness)**: 후보 키는 테이블 내에서 두 개의 서로 다른 튜플이 동일한 키 값을 가질 수 없다는 것을 보장합니다.
- **비환원성(Irreducibility)**: 후보 키는 더 이상 속성을 제거할 수 없을 정도로 최소한의 속성 집합이어야 합니다. 즉, 후보 키에서 어떤 속성을 제거하면 유일성 속성이 유지되지 않아야 합니다.

**기본 키**는 특별한 처리를 위해 선택된 후보 키입니다. 만약 관계에 후보 키가 하나만 있다면, 그 키를 기본 키로 지정하는 것이 자연스러운 선택입니다. 그러나 두 개 이상의 후보 키가 존재할 경우, 그 중 하나를 기본 키로 선택하는 것이 일반적입니다. 기본 키로 선택된 키는 다른 키들보다 "더 중요하다"는 의미를 가집니다.

마지막으로, **외래 키**는 한 테이블의 속성 집합으로, 다른 테이블의 후보 키를 참조합니다. 외래 키는 테이블 간의 관계를 정의하며, 데이터베이스의 무결성을 유지하는 데 중요한 역할을 합니다. 외래 키는 참조하는 테이블의 기본 키 값과 일치해야 하며, 이를 통해 데이터의 일관성을 보장합니다.

- 외래 키는 한 테이블(R2)의 속성 집합(FK)이 다른 테이블(R1)의 키(K)와 일치해야 한다는 제약 조건을 가집니다. R2의 모든 튜플은 R1의 적어도 하나의 튜플과 FK와 K가 동일한 값을 가져야 합니다.
- 외래 키는 실용적인 중요성 때문에 관계형 모델의 일부로 정의되었지만, 본질적으로는 특정 무결성 제약 조건을 간단히 표현하는 방법에 불과합니다. 이는 키의 경우에도 마찬가지로, 실용적인 이점 때문에 제공되는 간단한 표현입니다.
- SQL에서 외래 키와 대응하는 키의 속성 이름을 가능하면 동일하게 유지하는 것이 좋습니다. 그러나 자기 참조 또는 동일한 테이블의 두 개의 외래 키가 같은 키를 참조하는 경우에는 이름을 동일하게 유지하기 어려울 수 있습니다.

## 무결성

무결성 제약 조건(간단히 제약 조건)은 기본적으로 TRUE로 평가되어야 하는 불리언 표현식입니다. 관계형 모델에는 모든 가능한 데이터베이스에 적용되는 두 가지 일반적인 제약 조건이 있습니다. 하나는 기본 키와 관련이 있고, 다른 하나는 외래 키와 관련이 있습니다:

1. **개체 무결성 규칙**: 기본 키 속성은 null을 허용하지 않습니다.
2. **참조 무결성 규칙**: 일치하지 않는 외래 키 값이 있어서는 안 됩니다.

먼저 참조 무결성 규칙을 살펴보겠습니다. 일치하지 않는 외래 키 값은 해당 후보 키(“대상 키”)의 동일한 값이 존재하지 않는 외래 키 값을 의미합니다. 참조 무결성 규칙은 외래 키가 대상 키의 값과 일치해야 함을 명확히 설명합니다. 이는 "B가 A를 참조하면 A가 반드시 존재해야 한다"는 원칙을 따릅니다.

이제 개체 무결성 규칙과 관련하여 null 값의 문제를 논의해보겠습니다. null 값은 관계형 데이터베이스에서 여러 가지 문제를 일으킬 수 있습니다:

1. **불확실성**: null은 값이 없음을 나타내지만, 그 이유는 다양할 수 있습니다. 값이 존재하지 않거나, 아직 입력되지 않았거나, 알 수 없는 경우 등 다양한 의미를 가질 수 있어 데이터의 의미가 불분명해질 수 있습니다.

2. **논리적 모호성**: null을 포함한 논리 연산은 예측하기 어려운 결과를 초래할 수 있습니다. 예를 들어, null과의 비교 연산은 결과가 null이 되어 TRUE나 FALSE가 아닌 알 수 없음(UNKNOWN)을 의미합니다. 이는 쿼리 결과를 예측하기 어렵게 만듭니다.

3. **데이터 무결성**: null 값이 많아지면 데이터의 무결성을 유지하기 어려워질 수 있습니다. 특히, 외래 키가 null일 경우 참조 무결성을 확인하는 데 어려움이 있을 수 있습니다.

4. **성능 문제**: null 값을 처리하는 데 추가적인 로직이 필요할 수 있으며, 이는 쿼리 성능에 영향을 미칠 수 있습니다. 특히, null 값을 고려한 조건문이나 인덱스를 사용할 때 성능 저하가 발생할 수 있습니다.

5. **데이터 분석의 어려움**: null 값은 데이터 분석 시 누락된 데이터로 간주될 수 있으며, 이는 분석 결과에 영향을 미칠 수 있습니다. null 값을 어떻게 처리할지 결정하는 것은 분석의 정확성과 신뢰성에 큰 영향을 미칩니다.

본질적으로 null은 값이 알려지지 않았음을 나타내는 마커일 뿐, 자체적으로 의미 있는 값은 아닙니다. 이러한 이유로 null 값의 사용은 신중해야 하며, 가능한 경우 명확한 대안(예: 기본값 사용)을 고려하는 것이 좋습니다. 데이터베이스 설계 시 이러한 점을 염두에 두어 데이터의 무결성과 명확성을 유지하는 것이 중요합니다.


## 조작

모델의 조작 부분은 다시 두 부분으로 나뉩니다:

- 관계 대수: 관계에 적용할 수 있는 연산자의 모음
- 관계 할당 연산자: 일부 관계 대수 표현식의 값을 특정 관계에 할당할 수 있게 해주는 연산자

관계 대수는 기존의 관계(테이블)로부터 새로운 관계를 생성할 수 있는 다양한 연산자로 구성됩니다. 이러한 연산자들은 입력으로 하나 이상의 관계를 받아 새로운 관계를 출력합니다. 이 과정에서 중요한 것은 출력이 다시 관계의 형태를 띤다는 점입니다. 이러한 특성 덕분에 여러 연산을 중첩하여 사용할 수 있습니다.

### 주요 연산자 소개

1. **Restrict**
   - 특정 조건을 만족하는 튜플만을 선택하여 반환합니다. 이는 데이터베이스에서 조건에 맞는 데이터를 필터링할 때 유용합니다.

2. **Projection**
   - 지정된 속성만을 남기고 나머지 속성을 제거하여 새로운 관계를 생성합니다. 필요한 정보만 추출하여 데이터를 단순화하는 데 사용됩니다.

3. **Product**
   - 두 관계의 모든 가능한 튜플 조합을 반환합니다. 이는 데카르트 곱으로도 알려져 있으며, 두 테이블 간의 모든 가능한 결합을 보여줍니다.

4. **Union**
   - 두 관계에 나타나는 모든 튜플을 포함하는 새로운 관계를 생성합니다. 이는 두 테이블의 데이터를 하나로 합치는 데 사용됩니다.

5. **Intersect**
   - 두 관계 모두에 나타나는 튜플만 포함하는 관계를 반환합니다. 이는 두 테이블 간의 공통 데이터를 찾는 데 유용합니다.

6. **Difference**
   - 첫 번째 관계에는 나타나지만 두 번째 관계에는 나타나지 않는 튜플을 반환합니다. 이는 두 관계 간의 차이를 계산하는 데 사용됩니다.

7. **Join**
   - 두 관계 각각에서 하나씩 가져온 두 튜플의 모든 가능한 조합을 포함하는 관계를 생성합니다. 특히, 두 관계의 공통 속성에 대해 공통 값을 가지는 경우에만 해당됩니다. 이는 자연 조인이라고도 불리며, 데이터베이스 연산에서 매우 중요합니다.

