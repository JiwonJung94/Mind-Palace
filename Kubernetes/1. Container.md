컨테이너(Container)는 애플리케이션과 그 실행에 필요한 모든 것을 하나의 패키지로 묶어 독립적으로 실행할 수 있도록 하는 기술입니다. 여기서 "필요한 모든 것"이란 애플리케이션 코드, 라이브러리, 종속성, 설정 파일 등을 포함합니다. 컨테이너는 가상화 기술의 한 형태로, **운영 체제 수준에서의 가상화**를 통해 애플리케이션을 격리하여 실행합니다.

쉽게 말해, 컨테이너는 "애플리케이션이 어디서나 동일하게 실행되도록 보장하는 가벼운 박스"와 같습니다.

컨테이너는 애플리케이션과 실행에 필요한 모든 것을 하나로 묶어, **운영 체제(OS)를 공유하면서도 독립적으로 실행되는 환경**을 제공합니다.

- **커널 공유**: 커널은 CPU, 메모리, 디스크 등 하드웨어 자원을 관리하는 운영 체제의 핵심 부분입니다. 컨테이너는 호스트 운영 체제의 커널을 공유하며, 별도의 운영 체제를 설치하지 않습니다.
- **격리된 실행 환경**: 각 컨테이너는 독립적인 파일 시스템, 네트워크, 프로세스를 가지며, 다른 컨테이너와 분리된 상태로 실행됩니다.

컨테이너의 **격리된 실행 환경**은 주로 운영 체제의 **네임스페이스**(Namespaces)와 **cgroups**(Control Groups)라는 두 가지 핵심 기술을 통해 구현됩니다.


### 네임스페이스 (Namespaces)

네임스페이스는 **운영 체제의 커널 레벨에서 제공하는 기능으로, 시스템 자원을 논리적으로 분리하여 프로세스가 독립된 환경에서 실행되도록 만드는 기술**입니다. 네임스페이스는 컨테이너가 서로 독립된 실행 환경을 가지도록 지원하며, 다음과 같은 자원을 분리합니다:

1. **PID 네임스페이스** (Process ID Namespace)
    
	- PID 네임스페이스는 프로세스 ID를 네임스페이스 단위로 분리합니다. 이는 프로세스 간 통신이나 신호 전송(예: `kill` 명령)을 차단합니다.
    - 각 컨테이너는 자신만의 PID 네임스페이스를 가지며, 해당 네임스페이스 내부에서만 프로세스 ID를 확인하거나 조작할 수 있습니다.
    - 상위(호스트) 네임스페이스에서는 모든 컨테이너의 프로세스를 볼 수 있지만, 하위 네임스페이스(컨테이너)에서는 자신의 네임스페이스 내부에 있는 프로세스만 볼 수 있습니다. 
    - 예를 들어, 호스트에서 PID 1000인 프로세스가 컨테이너 내부에서는 PID 1로 보일 수 있습니다.

2. **네트워크 네임스페이스** (Network Namespace)
    
    - 네트워크 네임스페이스는 네트워크 인터페이스(예: 이더넷, IP 주소 등)를 분리하여 각 컨테이너가 독립적인 네트워크 스택을 가지도록 합니다.
    - 이를 통해 컨테이너는 자신만의 IP 주소, 포트, 라우팅 테이블 등을 가지며, 서로 다른 컨테이너나 호스트와 독립적으로 통신할 수 있습니다.
    - 예를 들어, 두 개의 컨테이너가 동일한 포트(예: 8080)를 사용하더라도 서로 충돌하지 않습니다.
    - 컨테이너 간 통신은 브릿지 네트워크, 오버레이 네트워크, 또는 호스트 네트워크 설정 등을 통해 설정할 수 있습니다.

3. **마운트 네임스페이스** (Mount Namespace)
    
    - 마운트 네임스페이스는 파일 시스템의 마운트 포인트를 분리하여 각 컨테이너가 독립적인 파일 시스템 뷰를 가지도록 합니다.
    - 이를 통해 컨테이너는 자신만의 루트 파일 시스템(`/`)을 가지며, 호스트 파일 시스템이나 다른 컨테이너의 파일 시스템과 분리됩니다.
    - 필요에 따라 특정 디렉토리를 컨테이너에 마운트(공유)하거나, 읽기 전용으로 접근하도록 설정할 수도 있습니다.

4. **UTS 네임스페이스** (UNIX Timesharing System Namespace)
    
    - UTS 네임스페이스는 컨테이너가 독립적인 호스트 이름과 도메인 이름을 가지도록 합니다.
    - 이를 통해 각 컨테이너는 자신만의 호스트 이름을 설정할 수 있으며, 호스트나 다른 컨테이너의 호스트 이름과 분리됩니다.

5. **IPC 네임스페이스** (Inter-Process Communication Namespace)
    
    - IPC 네임스페이스는 컨테이너 간의 프로세스 간 통신(Shared Memory, Semaphores 등)을 분리합니다.
    - 이를 통해 컨테이너는 자신만의 IPC 자원을 가지며, 다른 컨테이너나 호스트와 충돌하지 않습니다.

6. **유저 네임스페이스** (User Namespace)
    
    - 유저 네임스페이스는 사용자와 그룹 ID를 네임스페이스 단위로 분리합니다.
    - 이를 통해 컨테이너 내부에서는 특정 사용자가 루트 권한을 가지더라도, 호스트에서는 비특권 사용자로 매핑될 수 있습니다.

### cgroups와 리소스 제어

컨테이너의 스케줄링은 **호스트 커널의 전체 프로세스 목록**을 기준으로 이루어지며, **cgroups**(Control Groups)를 통해 컨테이너별로 사용할 수 있는 리소스를 제한하거나 우선순위를 설정할 수 있습니다. **cgroups**는 리눅스 커널에서 제공하는 기능으로, **프로세스 그룹 단위로 CPU, 메모리, 디스크 I/O, 네트워크 대역폭 등의 시스템 리소스를 관리**합니다.

#### cgroups의 주요 기능

1. **자원 제한**
    
    - 각 컨테이너가 사용할 수 있는 자원을 제한하여 과도한 자원 사용이 다른 컨테이너나 호스트에 영향을 미치지 않도록 합니다.
        - 예: CPU 사용량 50% 제한, 메모리 512MB 제한.
2. **자원 격리**
    
    - 각 컨테이너가 할당된 자원만 사용할 수 있도록 보장하여 자원 충돌 방지.
3. **자원 모니터링**
    
    - 컨테이너의 자원 사용량을 추적하여 이상 동작 감지 및 분석 가능.
4. **우선순위 설정**
    
    - 특정 컨테이너에 더 많은 자원을 할당하거나 우선순위를 부여.
        - 예: 중요한 컨테이너에 더 많은 CPU 시간을 할당.

#### 자원 제어의 예시

1. **CPU 제어**
    
    - **CPU share**: 컨테이너별 CPU 사용 비율 설정.
        - 예: 컨테이너 A에 1024, B에 512를 할당하면 A는 B보다 2배 더 많은 CPU 시간을 할당받음.
    - **CFS(Completely Fair Scheduler)**: 리눅스 커널의 기본 스케줄러로, cgroups의 CPU share 값을 기반으로 CPU 시간을 공정하게 분배.
2. **메모리 제한**
    
    - 컨테이너별 메모리 사용량의 최대치를 설정.
        - 예: 컨테이너 A는 최대 2GB로 제한.
    - 메모리 초과 시 **OOM(Out of Memory) 킬러**가 초과 프로세스를 종료.
3. **I/O 제어**
    
    - 디스크 I/O의 대역폭 및 우선순위 설정.
        - 예: 컨테이너 A는 초당 100MB, B는 50MB로 제한.


