**Pod**는 쿠버네티스(Kubernetes)의 **가장 작은 배포 단위**로, 하나 이상의 컨테이너(Container)를 묶는 논리적인 단위입니다. Pod는 동일한 애플리케이션을 실행하거나 밀접하게 연관된 작업을 수행하는 컨테이너들을 그룹화하여 관리합니다. Pod 내의 컨테이너들은 네트워크, 스토리지, 환경변수 등을 공유하며, 하나의 배포 단위로 동작합니다.

1. **컨테이너 그룹**:
	- **Pod는 하나 이상의 컨테이너를 포함**:
	    - 일반적으로 Pod는 하나의 컨테이너를 포함하는 경우가 많지만, 특정 시나리오에서는 여러 컨테이너를 함께 실행해야 할 필요가 있습니다.
	- **사이드카 패턴(Sidecar Pattern)**:
	    - 여러 컨테이너가 포함된 Pod의 대표적인 사례로, 사이드카 패턴이 있습니다.
	    - 예를 들어, 애플리케이션 컨테이너와 로그를 수집하거나 데이터를 동기화하는 보조 컨테이너를 하나의 Pod에 배치하여 함께 동작하도록 설정할 수 있습니다.
	    - 이러한 방식으로 Pod는 밀접하게 연관된 작업을 수행하는 컨테이너들을 하나의 논리적 단위로 묶어 관리합니다.

2. **공유 네트워크**:
	- **Pod 내 네트워크 네임스페이스 공유**:
	    - Pod에 포함된 모든 컨테이너는 동일한 네트워크 네임스페이스를 공유합니다.
	    - 즉, 같은 IP 주소를 사용하며, `localhost`를 통해 서로 간의 통신이 가능합니다.
	    - 이는 Pod 내부의 컨테이너들이 마치 하나의 애플리케이션처럼 동작할 수 있도록 지원합니다.
	- **포트 충돌 방지**:
	    - Pod 내의 컨테이너들이 동일한 네트워크 네임스페이스를 공유하기 때문에, 각 컨테이너에서 사용하는 포트 번호는 고유해야 합니다.
	    - 예를 들어, 두 컨테이너가 모두 `8080` 포트를 사용하려고 하면 충돌이 발생합니다.
	- **Pod 외부와의 통신**:    
	    - Pod는 외부 네트워크와 통신하기 위해 쿠버네티스 서비스(Service) 객체를 사용합니다.
	    - 서비스는 Pod의 IP 주소가 변경되더라도 안정적인 네트워크 엔드포인트를 제공합니다.
	- **컨테이너에서 `0.0.0.0`으로 포트를 열 때**:
		- `0.0.0.0`은 **모든 네트워크 인터페이스**를 의미하므로 Pod 내의 모든 컨테이너뿐만 아니라, Pod 외부에서도 해당 포트에 접근할 수 있습니다.
		- 외부 접근을 제한하려면 네트워크 정책 (Network Policy) 또는 방화벽 설정이 필요합니다.
	- **컨테이너에서 `127.0.0.1`으로 포트를 열 때**:
		- `127.0.0.1`은 **로컬 루프백 주소**를 의미합니다.
		- 해당 컨테이너 내부에서만 포트가 노출되며, **Pod 내의 다른 컨테이너에서도 접근할 수 없습니다**.
		- 즉, 동일한 Pod 내의 다른 컨테이너에서 `localhost` 또는 `127.0.0.1`로 접근하려고 하면 연결되지 않습니다.

3. **스토리지 공유**:
	- **공유 볼륨**:
	    - Pod는 여러 컨테이너가 데이터를 공유할 수 있도록 공유 볼륨을 설정할 수 있습니다.
	    - 이 볼륨은 Pod 내의 모든 컨테이너가 접근 가능하며, 데이터를 읽거나 쓸 수 있습니다.
	- **데이터 지속성**:
	    - Pod가 삭제되거나 재시작되더라도 데이터를 유지하려면, 퍼시스턴트 볼륨(Persistent Volume, PV)을 사용해야 합니다.
	    - 퍼시스턴트 볼륨은 클러스터 외부의 스토리지(예: NFS, 클라우드 스토리지)와 연동되어 데이터를 영구적으로 저장합니다.

4. **단일 배포 단위**:
	- **Pod는 쿠버네티스의 기본 배포 단위**:
	    - 쿠버네티스에서 컨테이너를 직접 배포하는 대신, 항상 Pod 단위로 배포합니다.
	    - Pod는 스케줄링 및 배치를 위한 최소 단위로, 쿠버네티스가 클러스터 내의 노드(Node)에 Pod를 배치합니다.
	- **스케일링**:
	    - Pod는 필요에 따라 수평적으로 확장(스케일 아웃)하거나 축소(스케일 인)할 수 있습니다.
	    - 이를 위해 쿠버네티스는 `ReplicaSet`이나 `Deployment`와 같은 컨트롤러를 사용하여 Pod의 복제본을 관리합니다.
	    - 예를 들어, 애플리케이션의 트래픽이 증가하면 동일한 Pod의 복제본을 여러 개 생성하여 부하를 분산시킬 수 있습니다.
	- **수명 주기**:
	    - Pod는 일반적으로 일시적인 존재로 간주됩니다. Pod가 삭제되거나 장애가 발생하면, 쿠버네티스는 새로운 Pod를 생성하여 대체합니다.
	    - 따라서 Pod를 직접 관리하기보다는, 상위 레벨의 컨트롤러(예: Deployment)를 사용하여 Pod를 관리하는 것이 일반적입니다.

### Pod YAML 파일 기본 구조

Pod의 설정 파일은 보통 다음과 같은 구조를 가집니다:

````yaml
apiVersion: v1
kind: Pod
metadata:
  name: my-pod
  labels:
    app: my-app
spec:
  containers:
  - name: my-container
    image: nginx:latest
    ports:
    - containerPort: 80
````

- **apiVersion**: Pod 리소스의 API 버전입니다.
- **kind**: 리소스 종류로 여기서는 Pod입니다.
- **metadata**: Pod의 식별 정보를 담는 부분으로, name, labels 등이 포함됩니다.
- **spec**: Pod의 실제 동작 방식을 정의하는 섹션입니다. 컨테이너의 이미지, 사용 포트, 환경 변수, 볼륨 사용 방법 등 Pod 내부에서 실행될 컨테이너들의 상세 설정 정보를 포함합니다.
  - **containers**: Pod에 포함된 컨테이너의 목록을 기술합니다.
    - 각 컨테이너는 name, image, 포트 등 개별 설정을 가질 수 있습니다.

Pod 설정 파일 내에서 추가로 구성할 수 있는 항목들은 다음과 같습니다:

- **다중 컨테이너 설정**:  
  하나의 Pod 내에 여러 컨테이너를 정의하여 사이드카 패턴을 사용할 수 있습니다.

  ````yaml
  spec:
    containers:
    - name: app-container
      image: my-app-image:latest
      ports:
      - containerPort: 8080
    - name: sidecar-container
      image: log-collector:latest
  ````

- **환경 변수(Environment Variables)**:  
  컨테이너에 필요한 환경 변수를 설정할 수 있습니다.

  ````yaml
  spec:
    containers:
    - name: my-container
      image: my-image:latest
      env:
      - name: ENVIRONMENT
        value: "production"
  ````

- **리소스 제한(Resource Limits)**:  
  CPU와 메모리 같은 리소스 사용량을 제한하거나 보장합니다.

  ````yaml
  spec:
    containers:
    - name: my-container
      image: my-image:latest
      resources:
        requests:
          memory: "64Mi"
          cpu: "250m"
        limits:
          memory: "128Mi"
          cpu: "500m"
  ````

- **포트 설정**:  
  컨테이너가 외부와 통신하는 데 사용할 포트를 지정합니다.

  ````yaml
  spec:
    containers:
    - name: my-container
      image: my-image:latest
      ports:
      - containerPort: 8080
  ````


- **볼륨(Volumes)** 및 **볼륨 마운트**:  
  볼륨은 Pod의 라이프사이클 동안 데이터를 저장할 수 있는 디렉터리입니다. Pod가 삭제되면 기본적으로 볼륨에 저장된 데이터도 사라지지만, 특정 유형의 볼륨(PersistentVolume 등)을 사용하면 데이터 영속성을 유지할 수 있습니다.
	- **Pod 스코프**: 볼륨은 Pod 내 모든 컨테이너에서 접근할 수 있습니다.
	- **유형**:
	    - **emptyDir**: Pod가 노드에 할당될 때 생성되며, Pod가 삭제되면 데이터도 함께 삭제됩니다. 주로 임시 데이터 저장 용도로 사용됩니다.
	    - **hostPath**: 노드의 파일 시스템의 특정 경로를 공유합니다.
	    - **configMap/secret**: 설정 정보나 민감 데이터를 컨테이너에 주입할 때 사용합니다.
	    - **persistentVolumeClaim**: 외부 스토리지와 연동하여 데이터를 영구적으로 저장할 때 사용합니다.

  ````yaml
  spec:
    volumes:
    - name: shared-volume
      emptyDir: {}  # Pod 라이프사이클 동안 임시 저장소 역할
    containers:
    - name: my-container
      image: my-image:latest
      volumeMounts:
      - mountPath: /data
        name: shared-volume
  ````

