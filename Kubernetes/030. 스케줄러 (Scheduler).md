스케줄러는 클러스터의 리소스 사용 상태와 Pod의 요구 사항을 기반으로 최적의 노드를 선택하여 작업을 할당합니다.

1. **확장성**
    - 기본 스케줄러 외에도 사용자 정의 스케줄러(Custom Scheduler)를 구현하여 특정 요구 사항에 맞는 스케줄링 정책을 적용할 수 있습니다.
    - 다중 스케줄러를 동시에 실행할 수도 있습니다.

2. **정책 기반 스케줄링**    
    - Kubernetes는 다양한 스케줄링 정책을 지원하여 유연한 배치를 가능하게 합니다.
    - 주요 정책:
        - **Node Affinity/Anti-Affinity**: 특정 노드에 Pod를 배치하거나 배치를 회피.
        - **Pod Affinity/Anti-Affinity**: 특정 Pod와 가까운 위치에 배치하거나 멀리 배치.
        - **Taints and Tolerations**: 특정 노드를 특정 워크로드만 사용할 수 있도록 제한.

3. **다양한 스케줄링 알고리즘**
    - 스케줄러는 기본적으로 **Greedy 알고리즘**을 사용하여 최적의 노드를 선택하지만, 플러그인을 통해 알고리즘을 확장하거나 교체할 수 있습니다.

4. **Watch 메커니즘**    
    - 스케줄러는 Kubernetes API 서버의 Watch 메커니즘을 통해 클러스터 상태 변화를 실시간으로 감지합니다.

5. **플러그인 아키텍처**
    - Kubernetes 1.19부터 스케줄러는 플러그인 기반 아키텍처를 도입하여 사용자 정의 스케줄링 로직을 쉽게 추가할 수 있습니다.

### 주요 역할

1. **Pod 배치 결정**
    - 스케줄러는 아직 노드에 할당되지 않은 **대기 상태의 Pod**를 감지하고, 해당 Pod를 실행시킬 적합한 노드를 선택합니다.
    - Pod의 요구 사항(리소스, 네트워크, 스토리지 등)과 클러스터 상태를 고려하여 배치 결정을 내립니다.

2. **리소스 관리**
    - 스케줄러는 클러스터의 CPU, 메모리, 디스크와 같은 리소스를 효율적으로 사용하도록 Pod를 분배합니다.
    - 리소스가 부족하거나 특정 노드에 과부하가 걸리지 않도록 균형을 유지합니다.

3. **정책 기반 배치**    
    - 스케줄러는 사용자 정의 정책 및 제약 조건(PodAffinity, Taints, Tolerations 등)을 기반으로 배치를 수행합니다.
    - 예: 특정 워크로드를 GPU가 있는 노드에만 배치하거나, 특정 노드를 회피하도록 설정.

4. **클러스터 상태 모니터링**    
    - 스케줄러는 Kubernetes API 서버로부터 클러스터 상태 정보를 지속적으로 수신하여 최신 상태를 반영합니다.
    - 이를 통해 Pod의 요구 사항과 노드의 현재 상태를 비교하여 적합한 배치를 수행합니다.

### 스케줄링 프로세스

스케줄러는 다음과 같은 순서로 Pod를 배치합니다:

1. **대상 Pod 감지**
    - 스케줄러는 아직 노드에 할당되지 않은 **Pending 상태의 Pod**를 감지합니다.

2. **노드 필터링 (Filtering)**    
    - 스케줄러는 클러스터 내의 모든 노드를 대상으로 Pod의 요구 사항을 만족하는 노드를 필터링합니다.
    - 이 단계에서 고려되는 조건:
        - Pod의 리소스 요청(CPU, 메모리 등)이 노드의 가용 리소스를 초과하지 않는지 확인.
        - 노드의 Taints와 Pod의 Tolerations 간의 호환성.
        - 노드가 Pod의 네트워크 요구 사항을 충족하는지 확인.

3. **노드 점수 계산 (Scoring)**    
    - 필터링된 노드들에 대해 점수를 계산하여 최적의 노드를 선택합니다.
    - 점수 계산에 영향을 미치는 요소:
        - 리소스 사용률: 리소스 활용도를 최적화하기 위해 리소스가 적절히 분배되었는지 확인.
        - 데이터 로컬리티: Pod가 필요한 데이터에 가까운 노드로 배치.
        - 사용자 정의 정책: 사용자 정의 스케줄링 규칙에 따른 가중치 적용.

4. **최적 노드 선택**
    - 점수 계산 결과를 바탕으로 가장 높은 점수를 받은 노드를 선택하여 Pod를 배치합니다.

5. **결과 기록**    
    - 스케줄러는 선택된 노드를 Kubernetes API 서버에 기록하여 Pod가 해당 노드에서 실행되도록 합니다.

### 스케줄러의 주요 정책

1. **노드 선호도 (Node Affinity)**
    - 특정 노드에 Pod를 배치하도록 선호하거나 강제.
    - 예: 특정 애플리케이션은 GPU가 있는 노드에서만 실행.

2. **Pod 선호도 (Pod Affinity)**    
    - 특정 Pod와 가까운 노드에 배치.
    - 예: 동일한 애플리케이션의 여러 Pod가 동일한 노드에 배치되도록 설정.

3. **Pod 반감 (Pod Anti-Affinity)**    
    - 특정 Pod와 다른 노드에 배치.
    - 예: 고가용성을 위해 동일한 애플리케이션의 Pod를 서로 다른 노드에 배치.

4. **Taints and Tolerations**    
    - 특정 노드에 특정 워크로드만 배치하거나, 특정 Pod가 특정 노드를 회피하도록 설정.

5. **리소스 요청과 제한 (Resource Requests and Limits)**    
    - Pod가 요청한 리소스(CPU, 메모리 등)를 기준으로 적합한 노드를 선택.

### 한계와 고려 사항

1. **리소스 제약**
    - 클러스터의 리소스가 부족하면 스케줄러가 적합한 노드를 찾지 못할 수 있습니다.
    - 이를 방지하기 위해 클러스터 리소스를 모니터링하고 적절히 확장해야 합니다.

2. **복잡한 정책**
    - 복잡한 스케줄링 정책은 관리와 디버깅을 어렵게 만들 수 있습니다.
    - 정책 설정 시 클러스터의 요구 사항을 명확히 정의해야 합니다.

3. **대규모 클러스터**
    - 대규모 클러스터에서는 스케줄링 시간이 증가할 수 있습니다.
    - 이를 해결하기 위해 스케줄러의 성능을 조정하거나 사용자 정의 스케줄러를 사용해야 합니다.

