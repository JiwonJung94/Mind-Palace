컨테이너 런타임은 컨테이너를 생성, 실행, 중지 및 관리하는 소프트웨어입니다. Kubernetes는 Pod이라는 단위로 컨테이너를 관리하며, 컨테이너 런타임은 Pod 내부의 컨테이너를 실행하는 역할을 합니다.

- **주요 목적**:
    - 컨테이너 이미지의 다운로드 및 실행
    - 컨테이너의 라이프사이클 관리
    - 리소스 격리를 통해 안정적인 실행 환경 제공
    - Kubernetes와의 통합을 통해 클러스터 내에서 컨테이너를 효율적으로 관리

### 컨테이너 런타임의 주요 역할

#### 1. 컨테이너 실행

컨테이너 런타임은 Pod 정의(PodSpec)에 따라 컨테이너를 실행합니다. PodSpec에는 컨테이너 이미지, 환경 변수, 리소스 요청/제한 등이 포함되어 있으며, 컨테이너 런타임은 이를 기반으로 컨테이너를 생성합니다.

- 컨테이너 이미지를 레지스트리(예: Docker Hub, Google Container Registry)에서 가져옵니다.
- 컨테이너를 생성하고, 네트워크 인터페이스와 스토리지를 설정합니다.
- 컨테이너를 실행하고, 프로세스가 종료될 때까지 모니터링합니다.

#### 2. 이미지 관리

컨테이너 런타임은 컨테이너 이미지를 관리합니다. 이는 Kubernetes의 효율적인 동작을 위해 필수적인 기능입니다.

- **다운로드**: 컨테이너 런타임은 PodSpec에 명시된 이미지 태그를 기반으로 이미지를 다운로드합니다.
- **캐싱**: 동일한 이미지가 여러 Pod에서 사용될 경우, 중복 다운로드를 방지하기 위해 이미지를 캐싱합니다.
- **업데이트**: 이미지 태그가 `latest`인 경우 최신 버전을 확인하고 업데이트합니다.

#### 3. 리소스 격리

컨테이너 런타임은 컨테이너 간의 자원 충돌을 방지하기 위해 리소스 격리를 제공합니다. 이를 통해 하나의 컨테이너가 다른 컨테이너나 호스트 시스템에 영향을 미치지 않도록 보장합니다.

- **cgroup(Control Groups)**:
    - CPU, 메모리, 디스크 I/O 등 리소스 사용량을 제한합니다.
    - 특정 컨테이너가 과도한 리소스를 사용하는 것을 방지합니다.
- **namespace**:
    - 네트워크, 프로세스 ID, 파일 시스템 등을 격리합니다.
    - 컨테이너 간의 독립성을 유지합니다.

#### 4. 컨테이너 상태 관리

컨테이너 런타임은 실행 중인 컨테이너의 상태를 모니터링하고 관리합니다.

- **상태 확인**:
    - 컨테이너가 정상적으로 실행 중인지 확인합니다.
    - 비정상적으로 종료된 컨테이너를 감지합니다.
- **정리 작업**:
    - 종료된 컨테이너의 리소스를 해제하고, 사용되지 않는 이미지를 삭제합니다.
- **재시작**:
    - Kubernetes의 요구에 따라 실패한 컨테이너를 재시작합니다.


### 컨테이너 런타임 인터페이스(CRI)

Kubernetes는 다양한 컨테이너 런타임과의 호환성을 위해 **CRI**(Container Runtime Interface)를 도입했습니다. CRI는 **Kubelet과 컨테이너 런타임 간의 표준 인터페이스**로, Kubelet이 특정 컨테이너 런타임에 종속되지 않도록 설계되었습니다.

#### CRI의 주요 기능

1. **컨테이너 관리**:
    - 컨테이너를 생성, 시작, 중지, 삭제하는 작업을 수행합니다.
2. **이미지 관리**:
    - 이미지를 다운로드, 캐싱, 삭제하는 작업을 수행합니다.
3. **Pod 관리**:
    - Pod의 네트워크 및 스토리지 설정을 관리합니다.
4. **상태 보고**:
    - 컨테이너 및 Pod의 상태를 Kubelet에 보고합니다.

#### CRI의 동작 방식

- Kubelet은 CRI를 통해 컨테이너 런타임과 통신합니다.
- CRI는 gRPC를 기반으로 설계되어 있으며, 효율적이고 확장 가능한 통신을 지원합니다.
- Kubernetes는 다양한 런타임을 지원하기 위해 CRI 플러그인을 제공합니다.


### 컨테이너 런타임의 작동 방식

1. **컨테이너 이미지 다운로드**
    - 컨테이너 런타임은 PodSpec에 명시된 이미지 태그를 기반으로 컨테이너 이미지를 다운로드합니다.
    - 이미지는 OCI 표준을 따르는 컨테이너 레지스트리에서 가져옵니다.

2. **컨테이너 생성**
    - 컨테이너 런타임은 cgroup과 namespace를 사용하여 컨테이너를 생성합니다.
    - 네트워크 인터페이스와 스토리지를 설정합니다.

3. **컨테이너 실행**
    - 컨테이너 런타임은 컨테이너를 실행하고, 주 프로세스를 모니터링합니다.

4. **상태 보고**
    - 컨테이너 런타임은 컨테이너의 상태를 Kubelet에 보고합니다.
    - 상태 정보는 클러스터의 안정성을 유지하는 데 사용됩니다.

5. **컨테이너 종료 및 정리**
    - 컨테이너가 종료되면, 런타임은 관련 리소스를 해제하고, 사용되지 않는 이미지를 삭제합니다.

### 주요 컨테이너 런타임

#### 1. Docker

Docker는 가장 널리 알려진 컨테이너 런타임으로, 초기 Kubernetes에서 기본 런타임으로 사용되었습니다.

- **특징**:
    - 풍부한 에코시스템과 도구 지원.
    - 컨테이너 이미지 표준(OCI)을 따릅니다.
- **한계**:
    - Kubernetes에서는 Docker 자체가 아닌 Docker의 하위 런타임인 containerd를 통해 동작합니다.
    - 최근 Kubernetes는 Docker 대신 CRI 기반 런타임을 권장합니다.

#### 2. containerd

containerd는 Docker에서 분리된 경량화된 컨테이너 런타임으로, Kubernetes에서 널리 사용됩니다.

- **특징**:
    - CRI를 기본적으로 지원합니다.
    - 경량화되어 있으며, Kubernetes에 최적화되어 있습니다.
    - 컨테이너의 실행, 이미지 관리, 스토리지 및 네트워크 설정을 지원합니다.
- **장점**:
    - Docker보다 더 간단하고 성능이 뛰어납니다.
    - Kubernetes와의 통합이 용이합니다.

#### 3. CRI-O

CRI-O는 Kubernetes에 최적화된 컨테이너 런타임으로, Open Container Initiative(OCI) 표준을 따릅니다.

- **특징**:
    - CRI를 지원하며, Kubernetes와의 통합을 위해 설계되었습니다.
    - Docker와 비교하여 더 가볍고 단순합니다.
- **장점**:
    - Kubernetes에 특화되어 있으며, 불필요한 기능이 제거되어 성능이 우수합니다.

#### 4. 기타 런타임

- **rkt**:
    - CoreOS에서 개발한 컨테이너 런타임으로, 보안 및 성능에 중점을 둠.
    - 현재는 더 이상 개발이 진행되지 않음.
- **Kata Containers**:
    - 경량화된 가상 머신(VM)을 사용하여 컨테이너를 실행.
    - 보안 강화가 필요한 워크로드에 적합.


